/* automatically generated by rust-bindgen */

pub const FPDF_OBJECT_UNKNOWN: u32 = 0;
pub const FPDF_OBJECT_BOOLEAN: u32 = 1;
pub const FPDF_OBJECT_NUMBER: u32 = 2;
pub const FPDF_OBJECT_STRING: u32 = 3;
pub const FPDF_OBJECT_NAME: u32 = 4;
pub const FPDF_OBJECT_ARRAY: u32 = 5;
pub const FPDF_OBJECT_DICTIONARY: u32 = 6;
pub const FPDF_OBJECT_STREAM: u32 = 7;
pub const FPDF_OBJECT_NULLOBJ: u32 = 8;
pub const FPDF_OBJECT_REFERENCE: u32 = 9;
pub const FPDF_POLICY_MACHINETIME_ACCESS: u32 = 0;
pub const FPDF_ERR_SUCCESS: u32 = 0;
pub const FPDF_ERR_UNKNOWN: u32 = 1;
pub const FPDF_ERR_FILE: u32 = 2;
pub const FPDF_ERR_FORMAT: u32 = 3;
pub const FPDF_ERR_PASSWORD: u32 = 4;
pub const FPDF_ERR_SECURITY: u32 = 5;
pub const FPDF_ERR_PAGE: u32 = 6;
pub const FPDF_ANNOT: u32 = 1;
pub const FPDF_LCD_TEXT: u32 = 2;
pub const FPDF_NO_NATIVETEXT: u32 = 4;
pub const FPDF_GRAYSCALE: u32 = 8;
pub const FPDF_DEBUG_INFO: u32 = 128;
pub const FPDF_NO_CATCH: u32 = 256;
pub const FPDF_RENDER_LIMITEDIMAGECACHE: u32 = 512;
pub const FPDF_RENDER_FORCEHALFTONE: u32 = 1024;
pub const FPDF_PRINTING: u32 = 2048;
pub const FPDF_RENDER_NO_SMOOTHTEXT: u32 = 4096;
pub const FPDF_RENDER_NO_SMOOTHIMAGE: u32 = 8192;
pub const FPDF_RENDER_NO_SMOOTHPATH: u32 = 16384;
pub const FPDF_REVERSE_BYTE_ORDER: u32 = 16;
pub const FPDF_CONVERT_FILL_TO_STROKE: u32 = 32;
pub const FPDFBitmap_Unknown: u32 = 0;
pub const FPDFBitmap_Gray: u32 = 1;
pub const FPDFBitmap_BGR: u32 = 2;
pub const FPDFBitmap_BGRx: u32 = 3;
pub const FPDFBitmap_BGRA: u32 = 4;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 36;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const FPDF_COLORSPACE_UNKNOWN: u32 = 0;
pub const FPDF_COLORSPACE_DEVICEGRAY: u32 = 1;
pub const FPDF_COLORSPACE_DEVICERGB: u32 = 2;
pub const FPDF_COLORSPACE_DEVICECMYK: u32 = 3;
pub const FPDF_COLORSPACE_CALGRAY: u32 = 4;
pub const FPDF_COLORSPACE_CALRGB: u32 = 5;
pub const FPDF_COLORSPACE_LAB: u32 = 6;
pub const FPDF_COLORSPACE_ICCBASED: u32 = 7;
pub const FPDF_COLORSPACE_SEPARATION: u32 = 8;
pub const FPDF_COLORSPACE_DEVICEN: u32 = 9;
pub const FPDF_COLORSPACE_INDEXED: u32 = 10;
pub const FPDF_COLORSPACE_PATTERN: u32 = 11;
pub const FPDF_PAGEOBJ_UNKNOWN: u32 = 0;
pub const FPDF_PAGEOBJ_TEXT: u32 = 1;
pub const FPDF_PAGEOBJ_PATH: u32 = 2;
pub const FPDF_PAGEOBJ_IMAGE: u32 = 3;
pub const FPDF_PAGEOBJ_SHADING: u32 = 4;
pub const FPDF_PAGEOBJ_FORM: u32 = 5;
pub const FPDF_SEGMENT_UNKNOWN: i32 = -1;
pub const FPDF_SEGMENT_LINETO: u32 = 0;
pub const FPDF_SEGMENT_BEZIERTO: u32 = 1;
pub const FPDF_SEGMENT_MOVETO: u32 = 2;
pub const FPDF_FILLMODE_NONE: u32 = 0;
pub const FPDF_FILLMODE_ALTERNATE: u32 = 1;
pub const FPDF_FILLMODE_WINDING: u32 = 2;
pub const FPDF_FONT_TYPE1: u32 = 1;
pub const FPDF_FONT_TRUETYPE: u32 = 2;
pub const FPDF_LINECAP_BUTT: u32 = 0;
pub const FPDF_LINECAP_ROUND: u32 = 1;
pub const FPDF_LINECAP_PROJECTING_SQUARE: u32 = 2;
pub const FPDF_LINEJOIN_MITER: u32 = 0;
pub const FPDF_LINEJOIN_ROUND: u32 = 1;
pub const FPDF_LINEJOIN_BEVEL: u32 = 2;
pub const FPDF_PRINTMODE_EMF: u32 = 0;
pub const FPDF_PRINTMODE_TEXTONLY: u32 = 1;
pub const FPDF_PRINTMODE_POSTSCRIPT2: u32 = 2;
pub const FPDF_PRINTMODE_POSTSCRIPT3: u32 = 3;
pub const FPDF_PRINTMODE_POSTSCRIPT2_PASSTHROUGH: u32 = 4;
pub const FPDF_PRINTMODE_POSTSCRIPT3_PASSTHROUGH: u32 = 5;
pub const FPDF_PRINTMODE_EMF_IMAGE_MASKS: u32 = 6;
pub const FPDF_PRINTMODE_POSTSCRIPT3_TYPE42: u32 = 7;
pub const FPDF_PRINTMODE_POSTSCRIPT3_TYPE42_PASSTHROUGH: u32 = 8;
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
#[doc = " Define 'max_align_t' to match the GCC definition."]
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub const FPDF_TEXT_RENDERMODE_FPDF_TEXTRENDERMODE_UNKNOWN: FPDF_TEXT_RENDERMODE = -1;
pub const FPDF_TEXT_RENDERMODE_FPDF_TEXTRENDERMODE_FILL: FPDF_TEXT_RENDERMODE = 0;
pub const FPDF_TEXT_RENDERMODE_FPDF_TEXTRENDERMODE_STROKE: FPDF_TEXT_RENDERMODE = 1;
pub const FPDF_TEXT_RENDERMODE_FPDF_TEXTRENDERMODE_FILL_STROKE: FPDF_TEXT_RENDERMODE = 2;
pub const FPDF_TEXT_RENDERMODE_FPDF_TEXTRENDERMODE_INVISIBLE: FPDF_TEXT_RENDERMODE = 3;
pub const FPDF_TEXT_RENDERMODE_FPDF_TEXTRENDERMODE_FILL_CLIP: FPDF_TEXT_RENDERMODE = 4;
pub const FPDF_TEXT_RENDERMODE_FPDF_TEXTRENDERMODE_STROKE_CLIP: FPDF_TEXT_RENDERMODE = 5;
pub const FPDF_TEXT_RENDERMODE_FPDF_TEXTRENDERMODE_FILL_STROKE_CLIP: FPDF_TEXT_RENDERMODE = 6;
pub const FPDF_TEXT_RENDERMODE_FPDF_TEXTRENDERMODE_CLIP: FPDF_TEXT_RENDERMODE = 7;
pub const FPDF_TEXT_RENDERMODE_FPDF_TEXTRENDERMODE_LAST: FPDF_TEXT_RENDERMODE = 7;
#[doc = " PDF text rendering modes"]
pub type FPDF_TEXT_RENDERMODE = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_action_t__ {
    _unused: [u8; 0],
}
#[doc = " PDF types - use incomplete types (never completed) to force API type safety."]
pub type FPDF_ACTION = *mut fpdf_action_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_annotation_t__ {
    _unused: [u8; 0],
}
pub type FPDF_ANNOTATION = *mut fpdf_annotation_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_attachment_t__ {
    _unused: [u8; 0],
}
pub type FPDF_ATTACHMENT = *mut fpdf_attachment_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_avail_t__ {
    _unused: [u8; 0],
}
pub type FPDF_AVAIL = *mut fpdf_avail_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_bitmap_t__ {
    _unused: [u8; 0],
}
pub type FPDF_BITMAP = *mut fpdf_bitmap_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_bookmark_t__ {
    _unused: [u8; 0],
}
pub type FPDF_BOOKMARK = *mut fpdf_bookmark_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_clippath_t__ {
    _unused: [u8; 0],
}
pub type FPDF_CLIPPATH = *mut fpdf_clippath_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_dest_t__ {
    _unused: [u8; 0],
}
pub type FPDF_DEST = *mut fpdf_dest_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_document_t__ {
    _unused: [u8; 0],
}
pub type FPDF_DOCUMENT = *mut fpdf_document_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_font_t__ {
    _unused: [u8; 0],
}
pub type FPDF_FONT = *mut fpdf_font_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_form_handle_t__ {
    _unused: [u8; 0],
}
pub type FPDF_FORMHANDLE = *mut fpdf_form_handle_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_glyphpath_t__ {
    _unused: [u8; 0],
}
pub type FPDF_GLYPHPATH = *const fpdf_glyphpath_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_javascript_action_t {
    _unused: [u8; 0],
}
pub type FPDF_JAVASCRIPT_ACTION = *mut fpdf_javascript_action_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_link_t__ {
    _unused: [u8; 0],
}
pub type FPDF_LINK = *mut fpdf_link_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_page_t__ {
    _unused: [u8; 0],
}
pub type FPDF_PAGE = *mut fpdf_page_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_pagelink_t__ {
    _unused: [u8; 0],
}
pub type FPDF_PAGELINK = *mut fpdf_pagelink_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_pageobject_t__ {
    _unused: [u8; 0],
}
pub type FPDF_PAGEOBJECT = *mut fpdf_pageobject_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_pageobjectmark_t__ {
    _unused: [u8; 0],
}
pub type FPDF_PAGEOBJECTMARK = *mut fpdf_pageobjectmark_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_pagerange_t__ {
    _unused: [u8; 0],
}
pub type FPDF_PAGERANGE = *const fpdf_pagerange_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_pathsegment_t {
    _unused: [u8; 0],
}
pub type FPDF_PATHSEGMENT = *const fpdf_pathsegment_t;
pub type FPDF_RECORDER = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_schhandle_t__ {
    _unused: [u8; 0],
}
pub type FPDF_SCHHANDLE = *mut fpdf_schhandle_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_signature_t__ {
    _unused: [u8; 0],
}
pub type FPDF_SIGNATURE = *const fpdf_signature_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_structelement_t__ {
    _unused: [u8; 0],
}
pub type FPDF_STRUCTELEMENT = *mut fpdf_structelement_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_structelement_attr_t__ {
    _unused: [u8; 0],
}
pub type FPDF_STRUCTELEMENT_ATTR = *const fpdf_structelement_attr_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_structtree_t__ {
    _unused: [u8; 0],
}
pub type FPDF_STRUCTTREE = *mut fpdf_structtree_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_textpage_t__ {
    _unused: [u8; 0],
}
pub type FPDF_TEXTPAGE = *mut fpdf_textpage_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_widget_t__ {
    _unused: [u8; 0],
}
pub type FPDF_WIDGET = *mut fpdf_widget_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_xobject_t__ {
    _unused: [u8; 0],
}
pub type FPDF_XOBJECT = *mut fpdf_xobject_t__;
#[doc = " Basic data types"]
pub type FPDF_BOOL = ::std::os::raw::c_int;
pub type FPDF_RESULT = ::std::os::raw::c_int;
pub type FPDF_DWORD = ::std::os::raw::c_ulong;
pub type FS_FLOAT = f32;
pub const _FPDF_DUPLEXTYPE__DuplexUndefined: _FPDF_DUPLEXTYPE_ = 0;
pub const _FPDF_DUPLEXTYPE__Simplex: _FPDF_DUPLEXTYPE_ = 1;
pub const _FPDF_DUPLEXTYPE__DuplexFlipShortEdge: _FPDF_DUPLEXTYPE_ = 2;
pub const _FPDF_DUPLEXTYPE__DuplexFlipLongEdge: _FPDF_DUPLEXTYPE_ = 3;
#[doc = " Duplex types"]
pub type _FPDF_DUPLEXTYPE_ = u32;
#[doc = " Duplex types"]
pub use self::_FPDF_DUPLEXTYPE_ as FPDF_DUPLEXTYPE;
#[doc = " String types"]
pub type FPDF_WCHAR = ::std::os::raw::c_ushort;
#[doc = " FPDFSDK may use three types of strings: byte string, wide string (UTF-16LE"]
#[doc = " encoded), and platform dependent string"]
pub type FPDF_BYTESTRING = *const ::std::os::raw::c_char;
#[doc = " FPDFSDK always uses UTF-16LE encoded wide strings, each character uses 2"]
#[doc = " bytes (except surrogation), with the low byte first."]
pub type FPDF_WIDESTRING = *const FPDF_WCHAR;
#[doc = " Structure for persisting a string beyond the duration of a callback."]
#[doc = " Note: although represented as a char*, string may be interpreted as"]
#[doc = " a UTF-16LE formated string. Used only by XFA callbacks."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FPDF_BSTR_ {
    #[doc = " String buffer, manipulate only with FPDF_BStr_* methods."]
    pub str: *mut ::std::os::raw::c_char,
    #[doc = " Length of the string, in bytes."]
    pub len: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_FPDF_BSTR_() {
    assert_eq!(
        ::std::mem::size_of::<FPDF_BSTR_>(),
        16usize,
        concat!("Size of: ", stringify!(FPDF_BSTR_))
    );
    assert_eq!(
        ::std::mem::align_of::<FPDF_BSTR_>(),
        8usize,
        concat!("Alignment of ", stringify!(FPDF_BSTR_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_BSTR_>())).str as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_BSTR_),
            "::",
            stringify!(str)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_BSTR_>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_BSTR_),
            "::",
            stringify!(len)
        )
    );
}
#[doc = " Structure for persisting a string beyond the duration of a callback."]
#[doc = " Note: although represented as a char*, string may be interpreted as"]
#[doc = " a UTF-16LE formated string. Used only by XFA callbacks."]
pub type FPDF_BSTR = FPDF_BSTR_;
#[doc = " For Windows programmers: In most cases it's OK to treat FPDF_WIDESTRING as a"]
#[doc = " Windows unicode string, however, special care needs to be taken if you"]
#[doc = " expect to process Unicode larger than 0xffff."]
#[doc = ""]
#[doc = " For Linux/Unix programmers: most compiler/library environments use 4 bytes"]
#[doc = " for a Unicode character, and you have to convert between FPDF_WIDESTRING and"]
#[doc = " system wide string by yourself."]
pub type FPDF_STRING = *const ::std::os::raw::c_char;
#[doc = " Matrix for transformation, in the form [a b c d e f], equivalent to:"]
#[doc = " | a  b  0 |"]
#[doc = " | c  d  0 |"]
#[doc = " | e  f  1 |"]
#[doc = ""]
#[doc = " Translation is performed with [1 0 0 1 tx ty]."]
#[doc = " Scaling is performed with [sx 0 0 sy 0 0]."]
#[doc = " See PDF Reference 1.7, 4.2.2 Common Transformations for more."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FS_MATRIX_ {
    pub a: f32,
    pub b: f32,
    pub c: f32,
    pub d: f32,
    pub e: f32,
    pub f: f32,
}
#[test]
fn bindgen_test_layout__FS_MATRIX_() {
    assert_eq!(
        ::std::mem::size_of::<_FS_MATRIX_>(),
        24usize,
        concat!("Size of: ", stringify!(_FS_MATRIX_))
    );
    assert_eq!(
        ::std::mem::align_of::<_FS_MATRIX_>(),
        4usize,
        concat!("Alignment of ", stringify!(_FS_MATRIX_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FS_MATRIX_>())).a as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_MATRIX_),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FS_MATRIX_>())).b as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_MATRIX_),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FS_MATRIX_>())).c as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_MATRIX_),
            "::",
            stringify!(c)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FS_MATRIX_>())).d as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_MATRIX_),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FS_MATRIX_>())).e as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_MATRIX_),
            "::",
            stringify!(e)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FS_MATRIX_>())).f as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_MATRIX_),
            "::",
            stringify!(f)
        )
    );
}
#[doc = " Matrix for transformation, in the form [a b c d e f], equivalent to:"]
#[doc = " | a  b  0 |"]
#[doc = " | c  d  0 |"]
#[doc = " | e  f  1 |"]
#[doc = ""]
#[doc = " Translation is performed with [1 0 0 1 tx ty]."]
#[doc = " Scaling is performed with [sx 0 0 sy 0 0]."]
#[doc = " See PDF Reference 1.7, 4.2.2 Common Transformations for more."]
pub type FS_MATRIX = _FS_MATRIX_;
#[doc = " Rectangle area(float) in device or page coordinate system."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FS_RECTF_ {
    #[doc = " The x-coordinate of the left-top corner."]
    pub left: f32,
    #[doc = " The y-coordinate of the left-top corner."]
    pub top: f32,
    #[doc = " The x-coordinate of the right-bottom corner."]
    pub right: f32,
    #[doc = " The y-coordinate of the right-bottom corner."]
    pub bottom: f32,
}
#[test]
fn bindgen_test_layout__FS_RECTF_() {
    assert_eq!(
        ::std::mem::size_of::<_FS_RECTF_>(),
        16usize,
        concat!("Size of: ", stringify!(_FS_RECTF_))
    );
    assert_eq!(
        ::std::mem::align_of::<_FS_RECTF_>(),
        4usize,
        concat!("Alignment of ", stringify!(_FS_RECTF_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FS_RECTF_>())).left as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_RECTF_),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FS_RECTF_>())).top as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_RECTF_),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FS_RECTF_>())).right as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_RECTF_),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FS_RECTF_>())).bottom as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_RECTF_),
            "::",
            stringify!(bottom)
        )
    );
}
#[doc = " Rectangle area(float) in device or page coordinate system."]
pub type FS_LPRECTF = *mut _FS_RECTF_;
#[doc = " Rectangle area(float) in device or page coordinate system."]
pub type FS_RECTF = _FS_RECTF_;
#[doc = " Const Pointer to FS_RECTF structure."]
pub type FS_LPCRECTF = *const FS_RECTF;
#[doc = " Rectangle size. Coordinate system agnostic."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FS_SIZEF_ {
    pub width: f32,
    pub height: f32,
}
#[test]
fn bindgen_test_layout_FS_SIZEF_() {
    assert_eq!(
        ::std::mem::size_of::<FS_SIZEF_>(),
        8usize,
        concat!("Size of: ", stringify!(FS_SIZEF_))
    );
    assert_eq!(
        ::std::mem::align_of::<FS_SIZEF_>(),
        4usize,
        concat!("Alignment of ", stringify!(FS_SIZEF_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FS_SIZEF_>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FS_SIZEF_),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FS_SIZEF_>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FS_SIZEF_),
            "::",
            stringify!(height)
        )
    );
}
#[doc = " Rectangle size. Coordinate system agnostic."]
pub type FS_LPSIZEF = *mut FS_SIZEF_;
#[doc = " Rectangle size. Coordinate system agnostic."]
pub type FS_SIZEF = FS_SIZEF_;
#[doc = " Const Pointer to FS_SIZEF structure."]
pub type FS_LPCSIZEF = *const FS_SIZEF;
#[doc = " 2D Point. Coordinate system agnostic."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FS_POINTF_ {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_FS_POINTF_() {
    assert_eq!(
        ::std::mem::size_of::<FS_POINTF_>(),
        8usize,
        concat!("Size of: ", stringify!(FS_POINTF_))
    );
    assert_eq!(
        ::std::mem::align_of::<FS_POINTF_>(),
        4usize,
        concat!("Alignment of ", stringify!(FS_POINTF_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FS_POINTF_>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FS_POINTF_),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FS_POINTF_>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FS_POINTF_),
            "::",
            stringify!(y)
        )
    );
}
#[doc = " 2D Point. Coordinate system agnostic."]
pub type FS_LPPOINTF = *mut FS_POINTF_;
#[doc = " 2D Point. Coordinate system agnostic."]
pub type FS_POINTF = FS_POINTF_;
#[doc = " Const Pointer to FS_POINTF structure."]
pub type FS_LPCPOINTF = *const FS_POINTF;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FS_QUADPOINTSF {
    pub x1: FS_FLOAT,
    pub y1: FS_FLOAT,
    pub x2: FS_FLOAT,
    pub y2: FS_FLOAT,
    pub x3: FS_FLOAT,
    pub y3: FS_FLOAT,
    pub x4: FS_FLOAT,
    pub y4: FS_FLOAT,
}
#[test]
fn bindgen_test_layout__FS_QUADPOINTSF() {
    assert_eq!(
        ::std::mem::size_of::<_FS_QUADPOINTSF>(),
        32usize,
        concat!("Size of: ", stringify!(_FS_QUADPOINTSF))
    );
    assert_eq!(
        ::std::mem::align_of::<_FS_QUADPOINTSF>(),
        4usize,
        concat!("Alignment of ", stringify!(_FS_QUADPOINTSF))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FS_QUADPOINTSF>())).x1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_QUADPOINTSF),
            "::",
            stringify!(x1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FS_QUADPOINTSF>())).y1 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_QUADPOINTSF),
            "::",
            stringify!(y1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FS_QUADPOINTSF>())).x2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_QUADPOINTSF),
            "::",
            stringify!(x2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FS_QUADPOINTSF>())).y2 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_QUADPOINTSF),
            "::",
            stringify!(y2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FS_QUADPOINTSF>())).x3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_QUADPOINTSF),
            "::",
            stringify!(x3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FS_QUADPOINTSF>())).y3 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_QUADPOINTSF),
            "::",
            stringify!(y3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FS_QUADPOINTSF>())).x4 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_QUADPOINTSF),
            "::",
            stringify!(x4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FS_QUADPOINTSF>())).y4 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_QUADPOINTSF),
            "::",
            stringify!(y4)
        )
    );
}
pub type FS_QUADPOINTSF = _FS_QUADPOINTSF;
#[doc = " Annotation enums."]
pub type FPDF_ANNOTATION_SUBTYPE = ::std::os::raw::c_int;
pub type FPDF_ANNOT_APPEARANCEMODE = ::std::os::raw::c_int;
#[doc = " Dictionary value types."]
pub type FPDF_OBJECT_TYPE = ::std::os::raw::c_int;
extern "C" {
    #[doc = " Function: FPDF_InitLibrary"]
    #[doc = "          Initialize the FPDFSDK library"]
    #[doc = " Parameters:"]
    #[doc = "          None"]
    #[doc = " Return value:"]
    #[doc = "          None."]
    #[doc = " Comments:"]
    #[doc = "          Convenience function to call FPDF_InitLibraryWithConfig() for"]
    #[doc = "          backwards compatibility purposes. This will be deprecated in the"]
    #[doc = "          future."]
    pub fn FPDF_InitLibrary();
}
#[doc = " Anti-Grain Geometry - https://sourceforge.net/projects/agg/"]
pub const FPDF_RENDERER_TYPE_FPDF_RENDERERTYPE_AGG: FPDF_RENDERER_TYPE = 0;
#[doc = " Skia - https://skia.org/"]
pub const FPDF_RENDERER_TYPE_FPDF_RENDERERTYPE_SKIA: FPDF_RENDERER_TYPE = 1;
#[doc = " PDF renderer types - Experimental."]
#[doc = " Selection of 2D graphics library to use for rendering to FPDF_BITMAPs."]
pub type FPDF_RENDERER_TYPE = u32;
#[doc = " Process-wide options for initializing the library."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FPDF_LIBRARY_CONFIG_ {
    #[doc = " Version number of the interface. Currently must be 2."]
    #[doc = " Support for version 1 will be deprecated in the future."]
    pub version: ::std::os::raw::c_int,
    #[doc = " Array of paths to scan in place of the defaults when using built-in"]
    #[doc = " FXGE font loading code. The array is terminated by a NULL pointer."]
    #[doc = " The Array may be NULL itself to use the default paths. May be ignored"]
    #[doc = " entirely depending upon the platform."]
    pub m_pUserFontPaths: *mut *const ::std::os::raw::c_char,
    #[doc = " Pointer to the v8::Isolate to use, or NULL to force PDFium to create one."]
    pub m_pIsolate: *mut ::std::os::raw::c_void,
    #[doc = " The embedder data slot to use in the v8::Isolate to store PDFium's"]
    #[doc = " per-isolate data. The value needs to be in the range"]
    #[doc = " [0, |v8::Internals::kNumIsolateDataLots|). Note that 0 is fine for most"]
    #[doc = " embedders."]
    pub m_v8EmbedderSlot: ::std::os::raw::c_uint,
    #[doc = " Pointer to the V8::Platform to use."]
    pub m_pPlatform: *mut ::std::os::raw::c_void,
    #[doc = " Explicit specification of core renderer to use. |m_RendererType| must be"]
    #[doc = " a valid value for |FPDF_LIBRARY_CONFIG| versions of this level or higher,"]
    #[doc = " or else the initialization will fail with an immediate crash."]
    #[doc = " Note that use of a specified |FPDF_RENDERER_TYPE| value for which the"]
    #[doc = " corresponding render library is not included in the build will similarly"]
    #[doc = " fail with an immediate crash."]
    pub m_RendererType: FPDF_RENDERER_TYPE,
}
#[test]
fn bindgen_test_layout_FPDF_LIBRARY_CONFIG_() {
    assert_eq!(
        ::std::mem::size_of::<FPDF_LIBRARY_CONFIG_>(),
        48usize,
        concat!("Size of: ", stringify!(FPDF_LIBRARY_CONFIG_))
    );
    assert_eq!(
        ::std::mem::align_of::<FPDF_LIBRARY_CONFIG_>(),
        8usize,
        concat!("Alignment of ", stringify!(FPDF_LIBRARY_CONFIG_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_LIBRARY_CONFIG_>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_LIBRARY_CONFIG_),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FPDF_LIBRARY_CONFIG_>())).m_pUserFontPaths as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_LIBRARY_CONFIG_),
            "::",
            stringify!(m_pUserFontPaths)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_LIBRARY_CONFIG_>())).m_pIsolate as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_LIBRARY_CONFIG_),
            "::",
            stringify!(m_pIsolate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FPDF_LIBRARY_CONFIG_>())).m_v8EmbedderSlot as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_LIBRARY_CONFIG_),
            "::",
            stringify!(m_v8EmbedderSlot)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FPDF_LIBRARY_CONFIG_>())).m_pPlatform as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_LIBRARY_CONFIG_),
            "::",
            stringify!(m_pPlatform)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FPDF_LIBRARY_CONFIG_>())).m_RendererType as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_LIBRARY_CONFIG_),
            "::",
            stringify!(m_RendererType)
        )
    );
}
#[doc = " Process-wide options for initializing the library."]
pub type FPDF_LIBRARY_CONFIG = FPDF_LIBRARY_CONFIG_;
extern "C" {
    #[doc = " Function: FPDF_InitLibraryWithConfig"]
    #[doc = "          Initialize the FPDFSDK library"]
    #[doc = " Parameters:"]
    #[doc = "          config - configuration information as above."]
    #[doc = " Return value:"]
    #[doc = "          None."]
    #[doc = " Comments:"]
    #[doc = "          You have to call this function before you can call any PDF"]
    #[doc = "          processing functions."]
    pub fn FPDF_InitLibraryWithConfig(config: *const FPDF_LIBRARY_CONFIG);
}
extern "C" {
    #[doc = " Function: FPDF_DestroyLibary"]
    #[doc = "          Release all resources allocated by the FPDFSDK library."]
    #[doc = " Parameters:"]
    #[doc = "          None."]
    #[doc = " Return value:"]
    #[doc = "          None."]
    #[doc = " Comments:"]
    #[doc = "          You can call this function to release all memory blocks allocated by"]
    #[doc = "          the library."]
    #[doc = "          After this function is called, you should not call any PDF"]
    #[doc = "          processing functions."]
    pub fn FPDF_DestroyLibrary();
}
extern "C" {
    #[doc = " Function: FPDF_SetSandBoxPolicy"]
    #[doc = "          Set the policy for the sandbox environment."]
    #[doc = " Parameters:"]
    #[doc = "          policy -   The specified policy for setting, for example:"]
    #[doc = "                     FPDF_POLICY_MACHINETIME_ACCESS."]
    #[doc = "          enable -   True to enable, false to disable the policy."]
    #[doc = " Return value:"]
    #[doc = "          None."]
    pub fn FPDF_SetSandBoxPolicy(policy: FPDF_DWORD, enable: FPDF_BOOL);
}
extern "C" {
    #[doc = " Function: FPDF_LoadDocument"]
    #[doc = "          Open and load a PDF document."]
    #[doc = " Parameters:"]
    #[doc = "          file_path -  Path to the PDF file (including extension)."]
    #[doc = "          password  -  A string used as the password for the PDF file."]
    #[doc = "                       If no password is needed, empty or NULL can be used."]
    #[doc = "                       See comments below regarding the encoding."]
    #[doc = " Return value:"]
    #[doc = "          A handle to the loaded document, or NULL on failure."]
    #[doc = " Comments:"]
    #[doc = "          Loaded document can be closed by FPDF_CloseDocument()."]
    #[doc = "          If this function fails, you can use FPDF_GetLastError() to retrieve"]
    #[doc = "          the reason why it failed."]
    #[doc = ""]
    #[doc = "          The encoding for |file_path| is UTF-8."]
    #[doc = ""]
    #[doc = "          The encoding for |password| can be either UTF-8 or Latin-1. PDFs,"]
    #[doc = "          depending on the security handler revision, will only accept one or"]
    #[doc = "          the other encoding. If |password|'s encoding and the PDF's expected"]
    #[doc = "          encoding do not match, FPDF_LoadDocument() will automatically"]
    #[doc = "          convert |password| to the other encoding."]
    pub fn FPDF_LoadDocument(file_path: FPDF_STRING, password: FPDF_BYTESTRING) -> FPDF_DOCUMENT;
}
extern "C" {
    #[doc = " Function: FPDF_LoadMemDocument"]
    #[doc = "          Open and load a PDF document from memory."]
    #[doc = " Parameters:"]
    #[doc = "          data_buf    -   Pointer to a buffer containing the PDF document."]
    #[doc = "          size        -   Number of bytes in the PDF document."]
    #[doc = "          password    -   A string used as the password for the PDF file."]
    #[doc = "                          If no password is needed, empty or NULL can be used."]
    #[doc = " Return value:"]
    #[doc = "          A handle to the loaded document, or NULL on failure."]
    #[doc = " Comments:"]
    #[doc = "          The memory buffer must remain valid when the document is open."]
    #[doc = "          The loaded document can be closed by FPDF_CloseDocument."]
    #[doc = "          If this function fails, you can use FPDF_GetLastError() to retrieve"]
    #[doc = "          the reason why it failed."]
    #[doc = ""]
    #[doc = "          See the comments for FPDF_LoadDocument() regarding the encoding for"]
    #[doc = "          |password|."]
    #[doc = " Notes:"]
    #[doc = "          If PDFium is built with the XFA module, the application should call"]
    #[doc = "          FPDF_LoadXFA() function after the PDF document loaded to support XFA"]
    #[doc = "          fields defined in the fpdfformfill.h file."]
    pub fn FPDF_LoadMemDocument(
        data_buf: *const ::std::os::raw::c_void,
        size: ::std::os::raw::c_int,
        password: FPDF_BYTESTRING,
    ) -> FPDF_DOCUMENT;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Function: FPDF_LoadMemDocument64"]
    #[doc = "          Open and load a PDF document from memory."]
    #[doc = " Parameters:"]
    #[doc = "          data_buf    -   Pointer to a buffer containing the PDF document."]
    #[doc = "          size        -   Number of bytes in the PDF document."]
    #[doc = "          password    -   A string used as the password for the PDF file."]
    #[doc = "                          If no password is needed, empty or NULL can be used."]
    #[doc = " Return value:"]
    #[doc = "          A handle to the loaded document, or NULL on failure."]
    #[doc = " Comments:"]
    #[doc = "          The memory buffer must remain valid when the document is open."]
    #[doc = "          The loaded document can be closed by FPDF_CloseDocument."]
    #[doc = "          If this function fails, you can use FPDF_GetLastError() to retrieve"]
    #[doc = "          the reason why it failed."]
    #[doc = ""]
    #[doc = "          See the comments for FPDF_LoadDocument() regarding the encoding for"]
    #[doc = "          |password|."]
    #[doc = " Notes:"]
    #[doc = "          If PDFium is built with the XFA module, the application should call"]
    #[doc = "          FPDF_LoadXFA() function after the PDF document loaded to support XFA"]
    #[doc = "          fields defined in the fpdfformfill.h file."]
    pub fn FPDF_LoadMemDocument64(
        data_buf: *const ::std::os::raw::c_void,
        size: size_t,
        password: FPDF_BYTESTRING,
    ) -> FPDF_DOCUMENT;
}
#[doc = " Structure for custom file access."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FPDF_FILEACCESS {
    #[doc = " File length, in bytes."]
    pub m_FileLen: ::std::os::raw::c_ulong,
    #[doc = " A function pointer for getting a block of data from a specific position."]
    #[doc = " Position is specified by byte offset from the beginning of the file."]
    #[doc = " The pointer to the buffer is never NULL and the size is never 0."]
    #[doc = " The position and size will never go out of range of the file length."]
    #[doc = " It may be possible for FPDFSDK to call this function multiple times for"]
    #[doc = " the same position."]
    #[doc = " Return value: should be non-zero if successful, zero for error."]
    pub m_GetBlock: ::std::option::Option<
        unsafe extern "C" fn(
            param: *mut ::std::os::raw::c_void,
            position: ::std::os::raw::c_ulong,
            pBuf: *mut ::std::os::raw::c_uchar,
            size: ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " A custom pointer for all implementation specific data.  This pointer will"]
    #[doc = " be used as the first parameter to the m_GetBlock callback."]
    pub m_Param: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_FPDF_FILEACCESS() {
    assert_eq!(
        ::std::mem::size_of::<FPDF_FILEACCESS>(),
        24usize,
        concat!("Size of: ", stringify!(FPDF_FILEACCESS))
    );
    assert_eq!(
        ::std::mem::align_of::<FPDF_FILEACCESS>(),
        8usize,
        concat!("Alignment of ", stringify!(FPDF_FILEACCESS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_FILEACCESS>())).m_FileLen as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_FILEACCESS),
            "::",
            stringify!(m_FileLen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_FILEACCESS>())).m_GetBlock as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_FILEACCESS),
            "::",
            stringify!(m_GetBlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_FILEACCESS>())).m_Param as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_FILEACCESS),
            "::",
            stringify!(m_Param)
        )
    );
}
#[doc = " Structure for file reading or writing (I/O)."]
#[doc = ""]
#[doc = " Note: This is a handler and should be implemented by callers,"]
#[doc = " and is only used from XFA."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FPDF_FILEHANDLER_ {
    #[doc = " User-defined data."]
    #[doc = " Note: Callers can use this field to track controls."]
    pub clientData: *mut ::std::os::raw::c_void,
    #[doc = " Callback function to release the current file stream object."]
    #[doc = ""]
    #[doc = " Parameters:"]
    #[doc = "       clientData   -  Pointer to user-defined data."]
    #[doc = " Returns:"]
    #[doc = "       None."]
    pub Release:
        ::std::option::Option<unsafe extern "C" fn(clientData: *mut ::std::os::raw::c_void)>,
    #[doc = " Callback function to retrieve the current file stream size."]
    #[doc = ""]
    #[doc = " Parameters:"]
    #[doc = "       clientData   -  Pointer to user-defined data."]
    #[doc = " Returns:"]
    #[doc = "       Size of file stream."]
    pub GetSize: ::std::option::Option<
        unsafe extern "C" fn(clientData: *mut ::std::os::raw::c_void) -> FPDF_DWORD,
    >,
    #[doc = " Callback function to read data from the current file stream."]
    #[doc = ""]
    #[doc = " Parameters:"]
    #[doc = "       clientData   -  Pointer to user-defined data."]
    #[doc = "       offset       -  Offset position starts from the beginning of file"]
    #[doc = "                       stream. This parameter indicates reading position."]
    #[doc = "       buffer       -  Memory buffer to store data which are read from"]
    #[doc = "                       file stream. This parameter should not be NULL."]
    #[doc = "       size         -  Size of data which should be read from file stream,"]
    #[doc = "                       in bytes. The buffer indicated by |buffer| must be"]
    #[doc = "                       large enough to store specified data."]
    #[doc = " Returns:"]
    #[doc = "       0 for success, other value for failure."]
    pub ReadBlock: ::std::option::Option<
        unsafe extern "C" fn(
            clientData: *mut ::std::os::raw::c_void,
            offset: FPDF_DWORD,
            buffer: *mut ::std::os::raw::c_void,
            size: FPDF_DWORD,
        ) -> FPDF_RESULT,
    >,
    #[doc = " Callback function to write data into the current file stream."]
    #[doc = ""]
    #[doc = " Parameters:"]
    #[doc = "       clientData   -  Pointer to user-defined data."]
    #[doc = "       offset       -  Offset position starts from the beginning of file"]
    #[doc = "                       stream. This parameter indicates writing position."]
    #[doc = "       buffer       -  Memory buffer contains data which is written into"]
    #[doc = "                       file stream. This parameter should not be NULL."]
    #[doc = "       size         -  Size of data which should be written into file"]
    #[doc = "                       stream, in bytes."]
    #[doc = " Returns:"]
    #[doc = "       0 for success, other value for failure."]
    pub WriteBlock: ::std::option::Option<
        unsafe extern "C" fn(
            clientData: *mut ::std::os::raw::c_void,
            offset: FPDF_DWORD,
            buffer: *const ::std::os::raw::c_void,
            size: FPDF_DWORD,
        ) -> FPDF_RESULT,
    >,
    #[doc = " Callback function to flush all internal accessing buffers."]
    #[doc = ""]
    #[doc = " Parameters:"]
    #[doc = "       clientData   -  Pointer to user-defined data."]
    #[doc = " Returns:"]
    #[doc = "       0 for success, other value for failure."]
    pub Flush: ::std::option::Option<
        unsafe extern "C" fn(clientData: *mut ::std::os::raw::c_void) -> FPDF_RESULT,
    >,
    #[doc = " Callback function to change file size."]
    #[doc = ""]
    #[doc = " Description:"]
    #[doc = "       This function is called under writing mode usually. Implementer"]
    #[doc = "       can determine whether to realize it based on application requests."]
    #[doc = " Parameters:"]
    #[doc = "       clientData   -  Pointer to user-defined data."]
    #[doc = "       size         -  New size of file stream, in bytes."]
    #[doc = " Returns:"]
    #[doc = "       0 for success, other value for failure."]
    pub Truncate: ::std::option::Option<
        unsafe extern "C" fn(
            clientData: *mut ::std::os::raw::c_void,
            size: FPDF_DWORD,
        ) -> FPDF_RESULT,
    >,
}
#[test]
fn bindgen_test_layout_FPDF_FILEHANDLER_() {
    assert_eq!(
        ::std::mem::size_of::<FPDF_FILEHANDLER_>(),
        56usize,
        concat!("Size of: ", stringify!(FPDF_FILEHANDLER_))
    );
    assert_eq!(
        ::std::mem::align_of::<FPDF_FILEHANDLER_>(),
        8usize,
        concat!("Alignment of ", stringify!(FPDF_FILEHANDLER_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_FILEHANDLER_>())).clientData as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_FILEHANDLER_),
            "::",
            stringify!(clientData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_FILEHANDLER_>())).Release as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_FILEHANDLER_),
            "::",
            stringify!(Release)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_FILEHANDLER_>())).GetSize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_FILEHANDLER_),
            "::",
            stringify!(GetSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_FILEHANDLER_>())).ReadBlock as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_FILEHANDLER_),
            "::",
            stringify!(ReadBlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_FILEHANDLER_>())).WriteBlock as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_FILEHANDLER_),
            "::",
            stringify!(WriteBlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_FILEHANDLER_>())).Flush as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_FILEHANDLER_),
            "::",
            stringify!(Flush)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_FILEHANDLER_>())).Truncate as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_FILEHANDLER_),
            "::",
            stringify!(Truncate)
        )
    );
}
#[doc = " Structure for file reading or writing (I/O)."]
#[doc = ""]
#[doc = " Note: This is a handler and should be implemented by callers,"]
#[doc = " and is only used from XFA."]
pub type FPDF_FILEHANDLER = FPDF_FILEHANDLER_;
extern "C" {
    #[doc = " Function: FPDF_LoadCustomDocument"]
    #[doc = "          Load PDF document from a custom access descriptor."]
    #[doc = " Parameters:"]
    #[doc = "          pFileAccess -   A structure for accessing the file."]
    #[doc = "          password    -   Optional password for decrypting the PDF file."]
    #[doc = " Return value:"]
    #[doc = "          A handle to the loaded document, or NULL on failure."]
    #[doc = " Comments:"]
    #[doc = "          The application must keep the file resources |pFileAccess| points to"]
    #[doc = "          valid until the returned FPDF_DOCUMENT is closed. |pFileAccess|"]
    #[doc = "          itself does not need to outlive the FPDF_DOCUMENT."]
    #[doc = ""]
    #[doc = "          The loaded document can be closed with FPDF_CloseDocument()."]
    #[doc = ""]
    #[doc = "          See the comments for FPDF_LoadDocument() regarding the encoding for"]
    #[doc = "          |password|."]
    #[doc = " Notes:"]
    #[doc = "          If PDFium is built with the XFA module, the application should call"]
    #[doc = "          FPDF_LoadXFA() function after the PDF document loaded to support XFA"]
    #[doc = "          fields defined in the fpdfformfill.h file."]
    pub fn FPDF_LoadCustomDocument(
        pFileAccess: *mut FPDF_FILEACCESS,
        password: FPDF_BYTESTRING,
    ) -> FPDF_DOCUMENT;
}
extern "C" {
    #[doc = " Function: FPDF_GetFileVersion"]
    #[doc = "          Get the file version of the given PDF document."]
    #[doc = " Parameters:"]
    #[doc = "          doc         -   Handle to a document."]
    #[doc = "          fileVersion -   The PDF file version. File version: 14 for 1.4, 15"]
    #[doc = "                          for 1.5, ..."]
    #[doc = " Return value:"]
    #[doc = "          True if succeeds, false otherwise."]
    #[doc = " Comments:"]
    #[doc = "          If the document was created by FPDF_CreateNewDocument,"]
    #[doc = "          then this function will always fail."]
    pub fn FPDF_GetFileVersion(
        doc: FPDF_DOCUMENT,
        fileVersion: *mut ::std::os::raw::c_int,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FPDF_GetLastError"]
    #[doc = "          Get last error code when a function fails."]
    #[doc = " Parameters:"]
    #[doc = "          None."]
    #[doc = " Return value:"]
    #[doc = "          A 32-bit integer indicating error code as defined above."]
    #[doc = " Comments:"]
    #[doc = "          If the previous SDK call succeeded, the return value of this"]
    #[doc = "          function is not defined. This function only works in conjunction"]
    #[doc = "          with APIs that mention FPDF_GetLastError() in their documentation."]
    pub fn FPDF_GetLastError() -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Function: FPDF_DocumentHasValidCrossReferenceTable"]
    #[doc = "          Whether the document's cross reference table is valid or not."]
    #[doc = " Parameters:"]
    #[doc = "          document    -   Handle to a document. Returned by FPDF_LoadDocument."]
    #[doc = " Return value:"]
    #[doc = "          True if the PDF parser did not encounter problems parsing the cross"]
    #[doc = "          reference table. False if the parser could not parse the cross"]
    #[doc = "          reference table and the table had to be rebuild from other data"]
    #[doc = "          within the document."]
    #[doc = " Comments:"]
    #[doc = "          The return value can change over time as the PDF parser evolves."]
    pub fn FPDF_DocumentHasValidCrossReferenceTable(document: FPDF_DOCUMENT) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Function: FPDF_GetTrailerEnds"]
    #[doc = "          Get the byte offsets of trailer ends."]
    #[doc = " Parameters:"]
    #[doc = "          document    -   Handle to document. Returned by FPDF_LoadDocument()."]
    #[doc = "          buffer      -   The address of a buffer that receives the"]
    #[doc = "                          byte offsets."]
    #[doc = "          length      -   The size, in ints, of |buffer|."]
    #[doc = " Return value:"]
    #[doc = "          Returns the number of ints in the buffer on success, 0 on error."]
    #[doc = ""]
    #[doc = " |buffer| is an array of integers that describes the exact byte offsets of the"]
    #[doc = " trailer ends in the document. If |length| is less than the returned length,"]
    #[doc = " or |document| or |buffer| is NULL, |buffer| will not be modified."]
    pub fn FPDF_GetTrailerEnds(
        document: FPDF_DOCUMENT,
        buffer: *mut ::std::os::raw::c_uint,
        length: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Function: FPDF_GetDocPermission"]
    #[doc = "          Get file permission flags of the document."]
    #[doc = " Parameters:"]
    #[doc = "          document    -   Handle to a document. Returned by FPDF_LoadDocument."]
    #[doc = " Return value:"]
    #[doc = "          A 32-bit integer indicating permission flags. Please refer to the"]
    #[doc = "          PDF Reference for detailed descriptions. If the document is not"]
    #[doc = "          protected, 0xffffffff will be returned."]
    pub fn FPDF_GetDocPermissions(document: FPDF_DOCUMENT) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Function: FPDF_GetSecurityHandlerRevision"]
    #[doc = "          Get the revision for the security handler."]
    #[doc = " Parameters:"]
    #[doc = "          document    -   Handle to a document. Returned by FPDF_LoadDocument."]
    #[doc = " Return value:"]
    #[doc = "          The security handler revision number. Please refer to the PDF"]
    #[doc = "          Reference for a detailed description. If the document is not"]
    #[doc = "          protected, -1 will be returned."]
    pub fn FPDF_GetSecurityHandlerRevision(document: FPDF_DOCUMENT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function: FPDF_GetPageCount"]
    #[doc = "          Get total number of pages in the document."]
    #[doc = " Parameters:"]
    #[doc = "          document    -   Handle to document. Returned by FPDF_LoadDocument."]
    #[doc = " Return value:"]
    #[doc = "          Total number of pages in the document."]
    pub fn FPDF_GetPageCount(document: FPDF_DOCUMENT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function: FPDF_LoadPage"]
    #[doc = "          Load a page inside the document."]
    #[doc = " Parameters:"]
    #[doc = "          document    -   Handle to document. Returned by FPDF_LoadDocument"]
    #[doc = "          page_index  -   Index number of the page. 0 for the first page."]
    #[doc = " Return value:"]
    #[doc = "          A handle to the loaded page, or NULL if page load fails."]
    #[doc = " Comments:"]
    #[doc = "          The loaded page can be rendered to devices using FPDF_RenderPage."]
    #[doc = "          The loaded page can be closed using FPDF_ClosePage."]
    pub fn FPDF_LoadPage(document: FPDF_DOCUMENT, page_index: ::std::os::raw::c_int) -> FPDF_PAGE;
}
extern "C" {
    #[doc = " Experimental API"]
    #[doc = " Function: FPDF_GetPageWidthF"]
    #[doc = "          Get page width."]
    #[doc = " Parameters:"]
    #[doc = "          page        -   Handle to the page. Returned by FPDF_LoadPage()."]
    #[doc = " Return value:"]
    #[doc = "          Page width (excluding non-displayable area) measured in points."]
    #[doc = "          One point is 1/72 inch (around 0.3528 mm)."]
    pub fn FPDF_GetPageWidthF(page: FPDF_PAGE) -> f32;
}
extern "C" {
    #[doc = " Function: FPDF_GetPageWidth"]
    #[doc = "          Get page width."]
    #[doc = " Parameters:"]
    #[doc = "          page        -   Handle to the page. Returned by FPDF_LoadPage."]
    #[doc = " Return value:"]
    #[doc = "          Page width (excluding non-displayable area) measured in points."]
    #[doc = "          One point is 1/72 inch (around 0.3528 mm)."]
    #[doc = " Note:"]
    #[doc = "          Prefer FPDF_GetPageWidthF() above. This will be deprecated in the"]
    #[doc = "          future."]
    pub fn FPDF_GetPageWidth(page: FPDF_PAGE) -> f64;
}
extern "C" {
    #[doc = " Experimental API"]
    #[doc = " Function: FPDF_GetPageHeightF"]
    #[doc = "          Get page height."]
    #[doc = " Parameters:"]
    #[doc = "          page        -   Handle to the page. Returned by FPDF_LoadPage()."]
    #[doc = " Return value:"]
    #[doc = "          Page height (excluding non-displayable area) measured in points."]
    #[doc = "          One point is 1/72 inch (around 0.3528 mm)"]
    pub fn FPDF_GetPageHeightF(page: FPDF_PAGE) -> f32;
}
extern "C" {
    #[doc = " Function: FPDF_GetPageHeight"]
    #[doc = "          Get page height."]
    #[doc = " Parameters:"]
    #[doc = "          page        -   Handle to the page. Returned by FPDF_LoadPage."]
    #[doc = " Return value:"]
    #[doc = "          Page height (excluding non-displayable area) measured in points."]
    #[doc = "          One point is 1/72 inch (around 0.3528 mm)"]
    #[doc = " Note:"]
    #[doc = "          Prefer FPDF_GetPageHeightF() above. This will be deprecated in the"]
    #[doc = "          future."]
    pub fn FPDF_GetPageHeight(page: FPDF_PAGE) -> f64;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Function: FPDF_GetPageBoundingBox"]
    #[doc = "          Get the bounding box of the page. This is the intersection between"]
    #[doc = "          its media box and its crop box."]
    #[doc = " Parameters:"]
    #[doc = "          page        -   Handle to the page. Returned by FPDF_LoadPage."]
    #[doc = "          rect        -   Pointer to a rect to receive the page bounding box."]
    #[doc = "                          On an error, |rect| won't be filled."]
    #[doc = " Return value:"]
    #[doc = "          True for success."]
    pub fn FPDF_GetPageBoundingBox(page: FPDF_PAGE, rect: *mut FS_RECTF) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Function: FPDF_GetPageSizeByIndexF"]
    #[doc = "          Get the size of the page at the given index."]
    #[doc = " Parameters:"]
    #[doc = "          document    -   Handle to document. Returned by FPDF_LoadDocument()."]
    #[doc = "          page_index  -   Page index, zero for the first page."]
    #[doc = "          size        -   Pointer to a FS_SIZEF to receive the page size."]
    #[doc = "                          (in points)."]
    #[doc = " Return value:"]
    #[doc = "          Non-zero for success. 0 for error (document or page not found)."]
    pub fn FPDF_GetPageSizeByIndexF(
        document: FPDF_DOCUMENT,
        page_index: ::std::os::raw::c_int,
        size: *mut FS_SIZEF,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FPDF_GetPageSizeByIndex"]
    #[doc = "          Get the size of the page at the given index."]
    #[doc = " Parameters:"]
    #[doc = "          document    -   Handle to document. Returned by FPDF_LoadDocument."]
    #[doc = "          page_index  -   Page index, zero for the first page."]
    #[doc = "          width       -   Pointer to a double to receive the page width"]
    #[doc = "                          (in points)."]
    #[doc = "          height      -   Pointer to a double to receive the page height"]
    #[doc = "                          (in points)."]
    #[doc = " Return value:"]
    #[doc = "          Non-zero for success. 0 for error (document or page not found)."]
    #[doc = " Note:"]
    #[doc = "          Prefer FPDF_GetPageSizeByIndexF() above. This will be deprecated in"]
    #[doc = "          the future."]
    pub fn FPDF_GetPageSizeByIndex(
        document: FPDF_DOCUMENT,
        page_index: ::std::os::raw::c_int,
        width: *mut f64,
        height: *mut f64,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Struct for color scheme."]
#[doc = " Each should be a 32-bit value specifying the color, in 8888 ARGB format."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FPDF_COLORSCHEME_ {
    pub path_fill_color: FPDF_DWORD,
    pub path_stroke_color: FPDF_DWORD,
    pub text_fill_color: FPDF_DWORD,
    pub text_stroke_color: FPDF_DWORD,
}
#[test]
fn bindgen_test_layout_FPDF_COLORSCHEME_() {
    assert_eq!(
        ::std::mem::size_of::<FPDF_COLORSCHEME_>(),
        32usize,
        concat!("Size of: ", stringify!(FPDF_COLORSCHEME_))
    );
    assert_eq!(
        ::std::mem::align_of::<FPDF_COLORSCHEME_>(),
        8usize,
        concat!("Alignment of ", stringify!(FPDF_COLORSCHEME_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FPDF_COLORSCHEME_>())).path_fill_color as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_COLORSCHEME_),
            "::",
            stringify!(path_fill_color)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FPDF_COLORSCHEME_>())).path_stroke_color as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_COLORSCHEME_),
            "::",
            stringify!(path_stroke_color)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FPDF_COLORSCHEME_>())).text_fill_color as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_COLORSCHEME_),
            "::",
            stringify!(text_fill_color)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FPDF_COLORSCHEME_>())).text_stroke_color as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_COLORSCHEME_),
            "::",
            stringify!(text_stroke_color)
        )
    );
}
#[doc = " Struct for color scheme."]
#[doc = " Each should be a 32-bit value specifying the color, in 8888 ARGB format."]
pub type FPDF_COLORSCHEME = FPDF_COLORSCHEME_;
extern "C" {
    #[doc = " Function: FPDF_RenderPageBitmap"]
    #[doc = "          Render contents of a page to a device independent bitmap."]
    #[doc = " Parameters:"]
    #[doc = "          bitmap      -   Handle to the device independent bitmap (as the"]
    #[doc = "                          output buffer). The bitmap handle can be created"]
    #[doc = "                          by FPDFBitmap_Create or retrieved from an image"]
    #[doc = "                          object by FPDFImageObj_GetBitmap."]
    #[doc = "          page        -   Handle to the page. Returned by FPDF_LoadPage"]
    #[doc = "          start_x     -   Left pixel position of the display area in"]
    #[doc = "                          bitmap coordinates."]
    #[doc = "          start_y     -   Top pixel position of the display area in bitmap"]
    #[doc = "                          coordinates."]
    #[doc = "          size_x      -   Horizontal size (in pixels) for displaying the page."]
    #[doc = "          size_y      -   Vertical size (in pixels) for displaying the page."]
    #[doc = "          rotate      -   Page orientation:"]
    #[doc = "                            0 (normal)"]
    #[doc = "                            1 (rotated 90 degrees clockwise)"]
    #[doc = "                            2 (rotated 180 degrees)"]
    #[doc = "                            3 (rotated 90 degrees counter-clockwise)"]
    #[doc = "          flags       -   0 for normal display, or combination of the Page"]
    #[doc = "                          Rendering flags defined above. With the FPDF_ANNOT"]
    #[doc = "                          flag, it renders all annotations that do not require"]
    #[doc = "                          user-interaction, which are all annotations except"]
    #[doc = "                          widget and popup annotations."]
    #[doc = " Return value:"]
    #[doc = "          None."]
    pub fn FPDF_RenderPageBitmap(
        bitmap: FPDF_BITMAP,
        page: FPDF_PAGE,
        start_x: ::std::os::raw::c_int,
        start_y: ::std::os::raw::c_int,
        size_x: ::std::os::raw::c_int,
        size_y: ::std::os::raw::c_int,
        rotate: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Function: FPDF_RenderPageBitmapWithMatrix"]
    #[doc = "          Render contents of a page to a device independent bitmap."]
    #[doc = " Parameters:"]
    #[doc = "          bitmap      -   Handle to the device independent bitmap (as the"]
    #[doc = "                          output buffer). The bitmap handle can be created"]
    #[doc = "                          by FPDFBitmap_Create or retrieved by"]
    #[doc = "                          FPDFImageObj_GetBitmap."]
    #[doc = "          page        -   Handle to the page. Returned by FPDF_LoadPage."]
    #[doc = "          matrix      -   The transform matrix, which must be invertible."]
    #[doc = "                          See PDF Reference 1.7, 4.2.2 Common Transformations."]
    #[doc = "          clipping    -   The rect to clip to in device coords."]
    #[doc = "          flags       -   0 for normal display, or combination of the Page"]
    #[doc = "                          Rendering flags defined above. With the FPDF_ANNOT"]
    #[doc = "                          flag, it renders all annotations that do not require"]
    #[doc = "                          user-interaction, which are all annotations except"]
    #[doc = "                          widget and popup annotations."]
    #[doc = " Return value:"]
    #[doc = "          None. Note that behavior is undefined if det of |matrix| is 0."]
    pub fn FPDF_RenderPageBitmapWithMatrix(
        bitmap: FPDF_BITMAP,
        page: FPDF_PAGE,
        matrix: *const FS_MATRIX,
        clipping: *const FS_RECTF,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Function: FPDF_ClosePage"]
    #[doc = "          Close a loaded PDF page."]
    #[doc = " Parameters:"]
    #[doc = "          page        -   Handle to the loaded page."]
    #[doc = " Return value:"]
    #[doc = "          None."]
    pub fn FPDF_ClosePage(page: FPDF_PAGE);
}
extern "C" {
    #[doc = " Function: FPDF_CloseDocument"]
    #[doc = "          Close a loaded PDF document."]
    #[doc = " Parameters:"]
    #[doc = "          document    -   Handle to the loaded document."]
    #[doc = " Return value:"]
    #[doc = "          None."]
    pub fn FPDF_CloseDocument(document: FPDF_DOCUMENT);
}
extern "C" {
    #[doc = " Function: FPDF_DeviceToPage"]
    #[doc = "          Convert the screen coordinates of a point to page coordinates."]
    #[doc = " Parameters:"]
    #[doc = "          page        -   Handle to the page. Returned by FPDF_LoadPage."]
    #[doc = "          start_x     -   Left pixel position of the display area in"]
    #[doc = "                          device coordinates."]
    #[doc = "          start_y     -   Top pixel position of the display area in device"]
    #[doc = "                          coordinates."]
    #[doc = "          size_x      -   Horizontal size (in pixels) for displaying the page."]
    #[doc = "          size_y      -   Vertical size (in pixels) for displaying the page."]
    #[doc = "          rotate      -   Page orientation:"]
    #[doc = "                            0 (normal)"]
    #[doc = "                            1 (rotated 90 degrees clockwise)"]
    #[doc = "                            2 (rotated 180 degrees)"]
    #[doc = "                            3 (rotated 90 degrees counter-clockwise)"]
    #[doc = "          device_x    -   X value in device coordinates to be converted."]
    #[doc = "          device_y    -   Y value in device coordinates to be converted."]
    #[doc = "          page_x      -   A pointer to a double receiving the converted X"]
    #[doc = "                          value in page coordinates."]
    #[doc = "          page_y      -   A pointer to a double receiving the converted Y"]
    #[doc = "                          value in page coordinates."]
    #[doc = " Return value:"]
    #[doc = "          Returns true if the conversion succeeds, and |page_x| and |page_y|"]
    #[doc = "          successfully receives the converted coordinates."]
    #[doc = " Comments:"]
    #[doc = "          The page coordinate system has its origin at the left-bottom corner"]
    #[doc = "          of the page, with the X-axis on the bottom going to the right, and"]
    #[doc = "          the Y-axis on the left side going up."]
    #[doc = ""]
    #[doc = "          NOTE: this coordinate system can be altered when you zoom, scroll,"]
    #[doc = "          or rotate a page, however, a point on the page should always have"]
    #[doc = "          the same coordinate values in the page coordinate system."]
    #[doc = ""]
    #[doc = "          The device coordinate system is device dependent. For screen device,"]
    #[doc = "          its origin is at the left-top corner of the window. However this"]
    #[doc = "          origin can be altered by the Windows coordinate transformation"]
    #[doc = "          utilities."]
    #[doc = ""]
    #[doc = "          You must make sure the start_x, start_y, size_x, size_y"]
    #[doc = "          and rotate parameters have exactly same values as you used in"]
    #[doc = "          the FPDF_RenderPage() function call."]
    pub fn FPDF_DeviceToPage(
        page: FPDF_PAGE,
        start_x: ::std::os::raw::c_int,
        start_y: ::std::os::raw::c_int,
        size_x: ::std::os::raw::c_int,
        size_y: ::std::os::raw::c_int,
        rotate: ::std::os::raw::c_int,
        device_x: ::std::os::raw::c_int,
        device_y: ::std::os::raw::c_int,
        page_x: *mut f64,
        page_y: *mut f64,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FPDF_PageToDevice"]
    #[doc = "          Convert the page coordinates of a point to screen coordinates."]
    #[doc = " Parameters:"]
    #[doc = "          page        -   Handle to the page. Returned by FPDF_LoadPage."]
    #[doc = "          start_x     -   Left pixel position of the display area in"]
    #[doc = "                          device coordinates."]
    #[doc = "          start_y     -   Top pixel position of the display area in device"]
    #[doc = "                          coordinates."]
    #[doc = "          size_x      -   Horizontal size (in pixels) for displaying the page."]
    #[doc = "          size_y      -   Vertical size (in pixels) for displaying the page."]
    #[doc = "          rotate      -   Page orientation:"]
    #[doc = "                            0 (normal)"]
    #[doc = "                            1 (rotated 90 degrees clockwise)"]
    #[doc = "                            2 (rotated 180 degrees)"]
    #[doc = "                            3 (rotated 90 degrees counter-clockwise)"]
    #[doc = "          page_x      -   X value in page coordinates."]
    #[doc = "          page_y      -   Y value in page coordinate."]
    #[doc = "          device_x    -   A pointer to an integer receiving the result X"]
    #[doc = "                          value in device coordinates."]
    #[doc = "          device_y    -   A pointer to an integer receiving the result Y"]
    #[doc = "                          value in device coordinates."]
    #[doc = " Return value:"]
    #[doc = "          Returns true if the conversion succeeds, and |device_x| and"]
    #[doc = "          |device_y| successfully receives the converted coordinates."]
    #[doc = " Comments:"]
    #[doc = "          See comments for FPDF_DeviceToPage()."]
    pub fn FPDF_PageToDevice(
        page: FPDF_PAGE,
        start_x: ::std::os::raw::c_int,
        start_y: ::std::os::raw::c_int,
        size_x: ::std::os::raw::c_int,
        size_y: ::std::os::raw::c_int,
        rotate: ::std::os::raw::c_int,
        page_x: f64,
        page_y: f64,
        device_x: *mut ::std::os::raw::c_int,
        device_y: *mut ::std::os::raw::c_int,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FPDFBitmap_Create"]
    #[doc = "          Create a device independent bitmap (FXDIB)."]
    #[doc = " Parameters:"]
    #[doc = "          width       -   The number of pixels in width for the bitmap."]
    #[doc = "                          Must be greater than 0."]
    #[doc = "          height      -   The number of pixels in height for the bitmap."]
    #[doc = "                          Must be greater than 0."]
    #[doc = "          alpha       -   A flag indicating whether the alpha channel is used."]
    #[doc = "                          Non-zero for using alpha, zero for not using."]
    #[doc = " Return value:"]
    #[doc = "          The created bitmap handle, or NULL if a parameter error or out of"]
    #[doc = "          memory."]
    #[doc = " Comments:"]
    #[doc = "          The bitmap always uses 4 bytes per pixel. The first byte is always"]
    #[doc = "          double word aligned."]
    #[doc = ""]
    #[doc = "          The byte order is BGRx (the last byte unused if no alpha channel) or"]
    #[doc = "          BGRA."]
    #[doc = ""]
    #[doc = "          The pixels in a horizontal line are stored side by side, with the"]
    #[doc = "          left most pixel stored first (with lower memory address)."]
    #[doc = "          Each line uses width * 4 bytes."]
    #[doc = ""]
    #[doc = "          Lines are stored one after another, with the top most line stored"]
    #[doc = "          first. There is no gap between adjacent lines."]
    #[doc = ""]
    #[doc = "          This function allocates enough memory for holding all pixels in the"]
    #[doc = "          bitmap, but it doesn't initialize the buffer. Applications can use"]
    #[doc = "          FPDFBitmap_FillRect() to fill the bitmap using any color. If the OS"]
    #[doc = "          allows it, this function can allocate up to 4 GB of memory."]
    pub fn FPDFBitmap_Create(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        alpha: ::std::os::raw::c_int,
    ) -> FPDF_BITMAP;
}
extern "C" {
    #[doc = " Function: FPDFBitmap_CreateEx"]
    #[doc = "          Create a device independent bitmap (FXDIB)"]
    #[doc = " Parameters:"]
    #[doc = "          width       -   The number of pixels in width for the bitmap."]
    #[doc = "                          Must be greater than 0."]
    #[doc = "          height      -   The number of pixels in height for the bitmap."]
    #[doc = "                          Must be greater than 0."]
    #[doc = "          format      -   A number indicating for bitmap format, as defined"]
    #[doc = "                          above."]
    #[doc = "          first_scan  -   A pointer to the first byte of the first line if"]
    #[doc = "                          using an external buffer. If this parameter is NULL,"]
    #[doc = "                          then a new buffer will be created."]
    #[doc = "          stride      -   Number of bytes for each scan line. The value must"]
    #[doc = "                          be 0 or greater. When the value is 0,"]
    #[doc = "                          FPDFBitmap_CreateEx() will automatically calculate"]
    #[doc = "                          the appropriate value using |width| and |format|."]
    #[doc = "                          When using an external buffer, it is recommended for"]
    #[doc = "                          the caller to pass in the value."]
    #[doc = "                          When not using an external buffer, it is recommended"]
    #[doc = "                          for the caller to pass in 0."]
    #[doc = " Return value:"]
    #[doc = "          The bitmap handle, or NULL if parameter error or out of memory."]
    #[doc = " Comments:"]
    #[doc = "          Similar to FPDFBitmap_Create function, but allows for more formats"]
    #[doc = "          and an external buffer is supported. The bitmap created by this"]
    #[doc = "          function can be used in any place that a FPDF_BITMAP handle is"]
    #[doc = "          required."]
    #[doc = ""]
    #[doc = "          If an external buffer is used, then the caller should destroy the"]
    #[doc = "          buffer. FPDFBitmap_Destroy() will not destroy the buffer."]
    #[doc = ""]
    #[doc = "          It is recommended to use FPDFBitmap_GetStride() to get the stride"]
    #[doc = "          value."]
    pub fn FPDFBitmap_CreateEx(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        format: ::std::os::raw::c_int,
        first_scan: *mut ::std::os::raw::c_void,
        stride: ::std::os::raw::c_int,
    ) -> FPDF_BITMAP;
}
extern "C" {
    #[doc = " Function: FPDFBitmap_GetFormat"]
    #[doc = "          Get the format of the bitmap."]
    #[doc = " Parameters:"]
    #[doc = "          bitmap      -   Handle to the bitmap. Returned by FPDFBitmap_Create"]
    #[doc = "                          or FPDFImageObj_GetBitmap."]
    #[doc = " Return value:"]
    #[doc = "          The format of the bitmap."]
    #[doc = " Comments:"]
    #[doc = "          Only formats supported by FPDFBitmap_CreateEx are supported by this"]
    #[doc = "          function; see the list of such formats above."]
    pub fn FPDFBitmap_GetFormat(bitmap: FPDF_BITMAP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function: FPDFBitmap_FillRect"]
    #[doc = "          Fill a rectangle in a bitmap."]
    #[doc = " Parameters:"]
    #[doc = "          bitmap      -   The handle to the bitmap. Returned by"]
    #[doc = "                          FPDFBitmap_Create."]
    #[doc = "          left        -   The left position. Starting from 0 at the"]
    #[doc = "                          left-most pixel."]
    #[doc = "          top         -   The top position. Starting from 0 at the"]
    #[doc = "                          top-most line."]
    #[doc = "          width       -   Width in pixels to be filled."]
    #[doc = "          height      -   Height in pixels to be filled."]
    #[doc = "          color       -   A 32-bit value specifing the color, in 8888 ARGB"]
    #[doc = "                          format."]
    #[doc = " Return value:"]
    #[doc = "          None."]
    #[doc = " Comments:"]
    #[doc = "          This function sets the color and (optionally) alpha value in the"]
    #[doc = "          specified region of the bitmap."]
    #[doc = ""]
    #[doc = "          NOTE: If the alpha channel is used, this function does NOT"]
    #[doc = "          composite the background with the source color, instead the"]
    #[doc = "          background will be replaced by the source color and the alpha."]
    #[doc = ""]
    #[doc = "          If the alpha channel is not used, the alpha parameter is ignored."]
    pub fn FPDFBitmap_FillRect(
        bitmap: FPDF_BITMAP,
        left: ::std::os::raw::c_int,
        top: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        color: FPDF_DWORD,
    );
}
extern "C" {
    #[doc = " Function: FPDFBitmap_GetBuffer"]
    #[doc = "          Get data buffer of a bitmap."]
    #[doc = " Parameters:"]
    #[doc = "          bitmap      -   Handle to the bitmap. Returned by FPDFBitmap_Create"]
    #[doc = "                          or FPDFImageObj_GetBitmap."]
    #[doc = " Return value:"]
    #[doc = "          The pointer to the first byte of the bitmap buffer."]
    #[doc = " Comments:"]
    #[doc = "          The stride may be more than width * number of bytes per pixel"]
    #[doc = ""]
    #[doc = "          Applications can use this function to get the bitmap buffer pointer,"]
    #[doc = "          then manipulate any color and/or alpha values for any pixels in the"]
    #[doc = "          bitmap."]
    #[doc = ""]
    #[doc = "          The data is in BGRA format. Where the A maybe unused if alpha was"]
    #[doc = "          not specified."]
    pub fn FPDFBitmap_GetBuffer(bitmap: FPDF_BITMAP) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Function: FPDFBitmap_GetWidth"]
    #[doc = "          Get width of a bitmap."]
    #[doc = " Parameters:"]
    #[doc = "          bitmap      -   Handle to the bitmap. Returned by FPDFBitmap_Create"]
    #[doc = "                          or FPDFImageObj_GetBitmap."]
    #[doc = " Return value:"]
    #[doc = "          The width of the bitmap in pixels."]
    pub fn FPDFBitmap_GetWidth(bitmap: FPDF_BITMAP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function: FPDFBitmap_GetHeight"]
    #[doc = "          Get height of a bitmap."]
    #[doc = " Parameters:"]
    #[doc = "          bitmap      -   Handle to the bitmap. Returned by FPDFBitmap_Create"]
    #[doc = "                          or FPDFImageObj_GetBitmap."]
    #[doc = " Return value:"]
    #[doc = "          The height of the bitmap in pixels."]
    pub fn FPDFBitmap_GetHeight(bitmap: FPDF_BITMAP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function: FPDFBitmap_GetStride"]
    #[doc = "          Get number of bytes for each line in the bitmap buffer."]
    #[doc = " Parameters:"]
    #[doc = "          bitmap      -   Handle to the bitmap. Returned by FPDFBitmap_Create"]
    #[doc = "                          or FPDFImageObj_GetBitmap."]
    #[doc = " Return value:"]
    #[doc = "          The number of bytes for each line in the bitmap buffer."]
    #[doc = " Comments:"]
    #[doc = "          The stride may be more than width * number of bytes per pixel."]
    pub fn FPDFBitmap_GetStride(bitmap: FPDF_BITMAP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function: FPDFBitmap_Destroy"]
    #[doc = "          Destroy a bitmap and release all related buffers."]
    #[doc = " Parameters:"]
    #[doc = "          bitmap      -   Handle to the bitmap. Returned by FPDFBitmap_Create"]
    #[doc = "                          or FPDFImageObj_GetBitmap."]
    #[doc = " Return value:"]
    #[doc = "          None."]
    #[doc = " Comments:"]
    #[doc = "          This function will not destroy any external buffers provided when"]
    #[doc = "          the bitmap was created."]
    pub fn FPDFBitmap_Destroy(bitmap: FPDF_BITMAP);
}
extern "C" {
    #[doc = " Function: FPDF_VIEWERREF_GetPrintScaling"]
    #[doc = "          Whether the PDF document prefers to be scaled or not."]
    #[doc = " Parameters:"]
    #[doc = "          document    -   Handle to the loaded document."]
    #[doc = " Return value:"]
    #[doc = "          None."]
    pub fn FPDF_VIEWERREF_GetPrintScaling(document: FPDF_DOCUMENT) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FPDF_VIEWERREF_GetNumCopies"]
    #[doc = "          Returns the number of copies to be printed."]
    #[doc = " Parameters:"]
    #[doc = "          document    -   Handle to the loaded document."]
    #[doc = " Return value:"]
    #[doc = "          The number of copies to be printed."]
    pub fn FPDF_VIEWERREF_GetNumCopies(document: FPDF_DOCUMENT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function: FPDF_VIEWERREF_GetPrintPageRange"]
    #[doc = "          Page numbers to initialize print dialog box when file is printed."]
    #[doc = " Parameters:"]
    #[doc = "          document    -   Handle to the loaded document."]
    #[doc = " Return value:"]
    #[doc = "          The print page range to be used for printing."]
    pub fn FPDF_VIEWERREF_GetPrintPageRange(document: FPDF_DOCUMENT) -> FPDF_PAGERANGE;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Function: FPDF_VIEWERREF_GetPrintPageRangeCount"]
    #[doc = "          Returns the number of elements in a FPDF_PAGERANGE."]
    #[doc = " Parameters:"]
    #[doc = "          pagerange   -   Handle to the page range."]
    #[doc = " Return value:"]
    #[doc = "          The number of elements in the page range. Returns 0 on error."]
    pub fn FPDF_VIEWERREF_GetPrintPageRangeCount(pagerange: FPDF_PAGERANGE) -> size_t;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Function: FPDF_VIEWERREF_GetPrintPageRangeElement"]
    #[doc = "          Returns an element from a FPDF_PAGERANGE."]
    #[doc = " Parameters:"]
    #[doc = "          pagerange   -   Handle to the page range."]
    #[doc = "          index       -   Index of the element."]
    #[doc = " Return value:"]
    #[doc = "          The value of the element in the page range at a given index."]
    #[doc = "          Returns -1 on error."]
    pub fn FPDF_VIEWERREF_GetPrintPageRangeElement(
        pagerange: FPDF_PAGERANGE,
        index: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function: FPDF_VIEWERREF_GetDuplex"]
    #[doc = "          Returns the paper handling option to be used when printing from"]
    #[doc = "          the print dialog."]
    #[doc = " Parameters:"]
    #[doc = "          document    -   Handle to the loaded document."]
    #[doc = " Return value:"]
    #[doc = "          The paper handling option to be used when printing."]
    pub fn FPDF_VIEWERREF_GetDuplex(document: FPDF_DOCUMENT) -> FPDF_DUPLEXTYPE;
}
extern "C" {
    #[doc = " Function: FPDF_VIEWERREF_GetName"]
    #[doc = "          Gets the contents for a viewer ref, with a given key. The value must"]
    #[doc = "          be of type \"name\"."]
    #[doc = " Parameters:"]
    #[doc = "          document    -   Handle to the loaded document."]
    #[doc = "          key         -   Name of the key in the viewer pref dictionary,"]
    #[doc = "                          encoded in UTF-8."]
    #[doc = "          buffer      -   A string to write the contents of the key to."]
    #[doc = "          length      -   Length of the buffer."]
    #[doc = " Return value:"]
    #[doc = "          The number of bytes in the contents, including the NULL terminator."]
    #[doc = "          Thus if the return value is 0, then that indicates an error, such"]
    #[doc = "          as when |document| is invalid or |buffer| is NULL. If |length| is"]
    #[doc = "          less than the returned length, or |buffer| is NULL, |buffer| will"]
    #[doc = "          not be modified."]
    pub fn FPDF_VIEWERREF_GetName(
        document: FPDF_DOCUMENT,
        key: FPDF_BYTESTRING,
        buffer: *mut ::std::os::raw::c_char,
        length: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Function: FPDF_CountNamedDests"]
    #[doc = "          Get the count of named destinations in the PDF document."]
    #[doc = " Parameters:"]
    #[doc = "          document    -   Handle to a document"]
    #[doc = " Return value:"]
    #[doc = "          The count of named destinations."]
    pub fn FPDF_CountNamedDests(document: FPDF_DOCUMENT) -> FPDF_DWORD;
}
extern "C" {
    #[doc = " Function: FPDF_GetNamedDestByName"]
    #[doc = "          Get a the destination handle for the given name."]
    #[doc = " Parameters:"]
    #[doc = "          document    -   Handle to the loaded document."]
    #[doc = "          name        -   The name of a destination."]
    #[doc = " Return value:"]
    #[doc = "          The handle to the destination."]
    pub fn FPDF_GetNamedDestByName(document: FPDF_DOCUMENT, name: FPDF_BYTESTRING) -> FPDF_DEST;
}
extern "C" {
    #[doc = " Function: FPDF_GetNamedDest"]
    #[doc = "          Get the named destination by index."]
    #[doc = " Parameters:"]
    #[doc = "          document        -   Handle to a document"]
    #[doc = "          index           -   The index of a named destination."]
    #[doc = "          buffer          -   The buffer to store the destination name,"]
    #[doc = "                              used as wchar_t*."]
    #[doc = "          buflen [in/out] -   Size of the buffer in bytes on input,"]
    #[doc = "                              length of the result in bytes on output"]
    #[doc = "                              or -1 if the buffer is too small."]
    #[doc = " Return value:"]
    #[doc = "          The destination handle for a given index, or NULL if there is no"]
    #[doc = "          named destination corresponding to |index|."]
    #[doc = " Comments:"]
    #[doc = "          Call this function twice to get the name of the named destination:"]
    #[doc = "            1) First time pass in |buffer| as NULL and get buflen."]
    #[doc = "            2) Second time pass in allocated |buffer| and buflen to retrieve"]
    #[doc = "               |buffer|, which should be used as wchar_t*."]
    #[doc = ""]
    #[doc = "         If buflen is not sufficiently large, it will be set to -1 upon"]
    #[doc = "         return."]
    pub fn FPDF_GetNamedDest(
        document: FPDF_DOCUMENT,
        index: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_void,
        buflen: *mut ::std::os::raw::c_long,
    ) -> FPDF_DEST;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Function: FPDF_GetXFAPacketCount"]
    #[doc = "          Get the number of valid packets in the XFA entry."]
    #[doc = " Parameters:"]
    #[doc = "          document - Handle to the document."]
    #[doc = " Return value:"]
    #[doc = "          The number of valid packets, or -1 on error."]
    pub fn FPDF_GetXFAPacketCount(document: FPDF_DOCUMENT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Function: FPDF_GetXFAPacketName"]
    #[doc = "          Get the name of a packet in the XFA array."]
    #[doc = " Parameters:"]
    #[doc = "          document - Handle to the document."]
    #[doc = "          index    - Index number of the packet. 0 for the first packet."]
    #[doc = "          buffer   - Buffer for holding the name of the XFA packet."]
    #[doc = "          buflen   - Length of |buffer| in bytes."]
    #[doc = " Return value:"]
    #[doc = "          The length of the packet name in bytes, or 0 on error."]
    #[doc = ""]
    #[doc = " |document| must be valid and |index| must be in the range [0, N), where N is"]
    #[doc = " the value returned by FPDF_GetXFAPacketCount()."]
    #[doc = " |buffer| is only modified if it is non-NULL and |buflen| is greater than or"]
    #[doc = " equal to the length of the packet name. The packet name includes a"]
    #[doc = " terminating NUL character. |buffer| is unmodified on error."]
    pub fn FPDF_GetXFAPacketName(
        document: FPDF_DOCUMENT,
        index: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_void,
        buflen: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Function: FPDF_GetXFAPacketContent"]
    #[doc = "          Get the content of a packet in the XFA array."]
    #[doc = " Parameters:"]
    #[doc = "          document   - Handle to the document."]
    #[doc = "          index      - Index number of the packet. 0 for the first packet."]
    #[doc = "          buffer     - Buffer for holding the content of the XFA packet."]
    #[doc = "          buflen     - Length of |buffer| in bytes."]
    #[doc = "          out_buflen - Pointer to the variable that will receive the minimum"]
    #[doc = "                       buffer size needed to contain the content of the XFA"]
    #[doc = "                       packet."]
    #[doc = " Return value:"]
    #[doc = "          Whether the operation succeeded or not."]
    #[doc = ""]
    #[doc = " |document| must be valid and |index| must be in the range [0, N), where N is"]
    #[doc = " the value returned by FPDF_GetXFAPacketCount(). |out_buflen| must not be"]
    #[doc = " NULL. When the aforementioned arguments are valid, the operation succeeds,"]
    #[doc = " and |out_buflen| receives the content size. |buffer| is only modified if"]
    #[doc = " |buffer| is non-null and long enough to contain the content. Callers must"]
    #[doc = " check both the return value and the input |buflen| is no less than the"]
    #[doc = " returned |out_buflen| before using the data in |buffer|."]
    pub fn FPDF_GetXFAPacketContent(
        document: FPDF_DOCUMENT,
        index: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_void,
        buflen: ::std::os::raw::c_ulong,
        out_buflen: *mut ::std::os::raw::c_ulong,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Set \"MediaBox\" entry to the page dictionary."]
    #[doc = ""]
    #[doc = " page   - Handle to a page."]
    #[doc = " left   - The left of the rectangle."]
    #[doc = " bottom - The bottom of the rectangle."]
    #[doc = " right  - The right of the rectangle."]
    #[doc = " top    - The top of the rectangle."]
    pub fn FPDFPage_SetMediaBox(page: FPDF_PAGE, left: f32, bottom: f32, right: f32, top: f32);
}
extern "C" {
    #[doc = " Set \"CropBox\" entry to the page dictionary."]
    #[doc = ""]
    #[doc = " page   - Handle to a page."]
    #[doc = " left   - The left of the rectangle."]
    #[doc = " bottom - The bottom of the rectangle."]
    #[doc = " right  - The right of the rectangle."]
    #[doc = " top    - The top of the rectangle."]
    pub fn FPDFPage_SetCropBox(page: FPDF_PAGE, left: f32, bottom: f32, right: f32, top: f32);
}
extern "C" {
    #[doc = " Set \"BleedBox\" entry to the page dictionary."]
    #[doc = ""]
    #[doc = " page   - Handle to a page."]
    #[doc = " left   - The left of the rectangle."]
    #[doc = " bottom - The bottom of the rectangle."]
    #[doc = " right  - The right of the rectangle."]
    #[doc = " top    - The top of the rectangle."]
    pub fn FPDFPage_SetBleedBox(page: FPDF_PAGE, left: f32, bottom: f32, right: f32, top: f32);
}
extern "C" {
    #[doc = " Set \"TrimBox\" entry to the page dictionary."]
    #[doc = ""]
    #[doc = " page   - Handle to a page."]
    #[doc = " left   - The left of the rectangle."]
    #[doc = " bottom - The bottom of the rectangle."]
    #[doc = " right  - The right of the rectangle."]
    #[doc = " top    - The top of the rectangle."]
    pub fn FPDFPage_SetTrimBox(page: FPDF_PAGE, left: f32, bottom: f32, right: f32, top: f32);
}
extern "C" {
    #[doc = " Set \"ArtBox\" entry to the page dictionary."]
    #[doc = ""]
    #[doc = " page   - Handle to a page."]
    #[doc = " left   - The left of the rectangle."]
    #[doc = " bottom - The bottom of the rectangle."]
    #[doc = " right  - The right of the rectangle."]
    #[doc = " top    - The top of the rectangle."]
    pub fn FPDFPage_SetArtBox(page: FPDF_PAGE, left: f32, bottom: f32, right: f32, top: f32);
}
extern "C" {
    #[doc = " Get \"MediaBox\" entry from the page dictionary."]
    #[doc = ""]
    #[doc = " page   - Handle to a page."]
    #[doc = " left   - Pointer to a float value receiving the left of the rectangle."]
    #[doc = " bottom - Pointer to a float value receiving the bottom of the rectangle."]
    #[doc = " right  - Pointer to a float value receiving the right of the rectangle."]
    #[doc = " top    - Pointer to a float value receiving the top of the rectangle."]
    #[doc = ""]
    #[doc = " On success, return true and write to the out parameters. Otherwise return"]
    #[doc = " false and leave the out parameters unmodified."]
    pub fn FPDFPage_GetMediaBox(
        page: FPDF_PAGE,
        left: *mut f32,
        bottom: *mut f32,
        right: *mut f32,
        top: *mut f32,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Get \"CropBox\" entry from the page dictionary."]
    #[doc = ""]
    #[doc = " page   - Handle to a page."]
    #[doc = " left   - Pointer to a float value receiving the left of the rectangle."]
    #[doc = " bottom - Pointer to a float value receiving the bottom of the rectangle."]
    #[doc = " right  - Pointer to a float value receiving the right of the rectangle."]
    #[doc = " top    - Pointer to a float value receiving the top of the rectangle."]
    #[doc = ""]
    #[doc = " On success, return true and write to the out parameters. Otherwise return"]
    #[doc = " false and leave the out parameters unmodified."]
    pub fn FPDFPage_GetCropBox(
        page: FPDF_PAGE,
        left: *mut f32,
        bottom: *mut f32,
        right: *mut f32,
        top: *mut f32,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Get \"BleedBox\" entry from the page dictionary."]
    #[doc = ""]
    #[doc = " page   - Handle to a page."]
    #[doc = " left   - Pointer to a float value receiving the left of the rectangle."]
    #[doc = " bottom - Pointer to a float value receiving the bottom of the rectangle."]
    #[doc = " right  - Pointer to a float value receiving the right of the rectangle."]
    #[doc = " top    - Pointer to a float value receiving the top of the rectangle."]
    #[doc = ""]
    #[doc = " On success, return true and write to the out parameters. Otherwise return"]
    #[doc = " false and leave the out parameters unmodified."]
    pub fn FPDFPage_GetBleedBox(
        page: FPDF_PAGE,
        left: *mut f32,
        bottom: *mut f32,
        right: *mut f32,
        top: *mut f32,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Get \"TrimBox\" entry from the page dictionary."]
    #[doc = ""]
    #[doc = " page   - Handle to a page."]
    #[doc = " left   - Pointer to a float value receiving the left of the rectangle."]
    #[doc = " bottom - Pointer to a float value receiving the bottom of the rectangle."]
    #[doc = " right  - Pointer to a float value receiving the right of the rectangle."]
    #[doc = " top    - Pointer to a float value receiving the top of the rectangle."]
    #[doc = ""]
    #[doc = " On success, return true and write to the out parameters. Otherwise return"]
    #[doc = " false and leave the out parameters unmodified."]
    pub fn FPDFPage_GetTrimBox(
        page: FPDF_PAGE,
        left: *mut f32,
        bottom: *mut f32,
        right: *mut f32,
        top: *mut f32,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Get \"ArtBox\" entry from the page dictionary."]
    #[doc = ""]
    #[doc = " page   - Handle to a page."]
    #[doc = " left   - Pointer to a float value receiving the left of the rectangle."]
    #[doc = " bottom - Pointer to a float value receiving the bottom of the rectangle."]
    #[doc = " right  - Pointer to a float value receiving the right of the rectangle."]
    #[doc = " top    - Pointer to a float value receiving the top of the rectangle."]
    #[doc = ""]
    #[doc = " On success, return true and write to the out parameters. Otherwise return"]
    #[doc = " false and leave the out parameters unmodified."]
    pub fn FPDFPage_GetArtBox(
        page: FPDF_PAGE,
        left: *mut f32,
        bottom: *mut f32,
        right: *mut f32,
        top: *mut f32,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Apply transforms to |page|."]
    #[doc = ""]
    #[doc = " If |matrix| is provided it will be applied to transform the page."]
    #[doc = " If |clipRect| is provided it will be used to clip the resulting page."]
    #[doc = " If neither |matrix| or |clipRect| are provided this method returns |false|."]
    #[doc = " Returns |true| if transforms are applied."]
    #[doc = ""]
    #[doc = " This function will transform the whole page, and would take effect to all the"]
    #[doc = " objects in the page."]
    #[doc = ""]
    #[doc = " page        - Page handle."]
    #[doc = " matrix      - Transform matrix."]
    #[doc = " clipRect    - Clipping rectangle."]
    pub fn FPDFPage_TransFormWithClip(
        page: FPDF_PAGE,
        matrix: *const FS_MATRIX,
        clipRect: *const FS_RECTF,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Transform (scale, rotate, shear, move) the clip path of page object."]
    #[doc = " page_object - Handle to a page object. Returned by"]
    #[doc = " FPDFPageObj_NewImageObj()."]
    #[doc = ""]
    #[doc = " a  - The coefficient \"a\" of the matrix."]
    #[doc = " b  - The coefficient \"b\" of the matrix."]
    #[doc = " c  - The coefficient \"c\" of the matrix."]
    #[doc = " d  - The coefficient \"d\" of the matrix."]
    #[doc = " e  - The coefficient \"e\" of the matrix."]
    #[doc = " f  - The coefficient \"f\" of the matrix."]
    pub fn FPDFPageObj_TransformClipPath(
        page_object: FPDF_PAGEOBJECT,
        a: f64,
        b: f64,
        c: f64,
        d: f64,
        e: f64,
        f: f64,
    );
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Get the clip path of the page object."]
    #[doc = ""]
    #[doc = "   page object - Handle to a page object. Returned by e.g."]
    #[doc = "                 FPDFPage_GetObject()."]
    #[doc = ""]
    #[doc = " Returns the handle to the clip path, or NULL on failure. The caller does not"]
    #[doc = " take ownership of the returned FPDF_CLIPPATH. Instead, it remains valid until"]
    #[doc = " FPDF_ClosePage() is called for the page containing |page_object|."]
    pub fn FPDFPageObj_GetClipPath(page_object: FPDF_PAGEOBJECT) -> FPDF_CLIPPATH;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Get number of paths inside |clip_path|."]
    #[doc = ""]
    #[doc = "   clip_path - handle to a clip_path."]
    #[doc = ""]
    #[doc = " Returns the number of objects in |clip_path| or -1 on failure."]
    pub fn FPDFClipPath_CountPaths(clip_path: FPDF_CLIPPATH) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Get number of segments inside one path of |clip_path|."]
    #[doc = ""]
    #[doc = "   clip_path  - handle to a clip_path."]
    #[doc = "   path_index - index into the array of paths of the clip path."]
    #[doc = ""]
    #[doc = " Returns the number of segments or -1 on failure."]
    pub fn FPDFClipPath_CountPathSegments(
        clip_path: FPDF_CLIPPATH,
        path_index: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Get segment in one specific path of |clip_path| at index."]
    #[doc = ""]
    #[doc = "   clip_path     - handle to a clip_path."]
    #[doc = "   path_index    - the index of a path."]
    #[doc = "   segment_index - the index of a segment."]
    #[doc = ""]
    #[doc = " Returns the handle to the segment, or NULL on failure. The caller does not"]
    #[doc = " take ownership of the returned FPDF_PATHSEGMENT. Instead, it remains valid"]
    #[doc = " until FPDF_ClosePage() is called for the page containing |clip_path|."]
    pub fn FPDFClipPath_GetPathSegment(
        clip_path: FPDF_CLIPPATH,
        path_index: ::std::os::raw::c_int,
        segment_index: ::std::os::raw::c_int,
    ) -> FPDF_PATHSEGMENT;
}
extern "C" {
    #[doc = " Create a new clip path, with a rectangle inserted."]
    #[doc = ""]
    #[doc = " Caller takes ownership of the returned FPDF_CLIPPATH. It should be freed with"]
    #[doc = " FPDF_DestroyClipPath()."]
    #[doc = ""]
    #[doc = " left   - The left of the clip box."]
    #[doc = " bottom - The bottom of the clip box."]
    #[doc = " right  - The right of the clip box."]
    #[doc = " top    - The top of the clip box."]
    pub fn FPDF_CreateClipPath(left: f32, bottom: f32, right: f32, top: f32) -> FPDF_CLIPPATH;
}
extern "C" {
    #[doc = " Destroy the clip path."]
    #[doc = ""]
    #[doc = " clipPath - A handle to the clip path. It will be invalid after this call."]
    pub fn FPDF_DestroyClipPath(clipPath: FPDF_CLIPPATH);
}
extern "C" {
    #[doc = " Clip the page content, the page content that outside the clipping region"]
    #[doc = " become invisible."]
    #[doc = ""]
    #[doc = " A clip path will be inserted before the page content stream or content array."]
    #[doc = " In this way, the page content will be clipped by this clip path."]
    #[doc = ""]
    #[doc = " page        - A page handle."]
    #[doc = " clipPath    - A handle to the clip path. (Does not take ownership.)"]
    pub fn FPDFPage_InsertClipPath(page: FPDF_PAGE, clipPath: FPDF_CLIPPATH);
}
#[doc = " Convenience types."]
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
#[doc = " Fixed-size types, underlying types depend on word size and compiler."]
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
#[doc = " Smallest types with at least a given width."]
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
#[doc = " These few don't really vary by system, they always correspond"]
#[doc = "to one of the other defined types."]
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
#[doc = " C99: An integer type that can be accessed as an atomic entity,"]
#[doc = "even in the presence of asynchronous interrupts."]
#[doc = "It is not currently necessary for this to be machine-specific."]
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[doc = " Signed."]
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
#[doc = " Unsigned."]
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
#[doc = " Signed."]
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
#[doc = " Unsigned."]
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
#[doc = " Largest integral types."]
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Gets the decoded data from the thumbnail of |page| if it exists."]
    #[doc = " This only modifies |buffer| if |buflen| less than or equal to the"]
    #[doc = " size of the decoded data. Returns the size of the decoded"]
    #[doc = " data or 0 if thumbnail DNE. Optional, pass null to just retrieve"]
    #[doc = " the size of the buffer needed."]
    #[doc = ""]
    #[doc = "   page    - handle to a page."]
    #[doc = "   buffer  - buffer for holding the decoded image data."]
    #[doc = "   buflen  - length of the buffer in bytes."]
    pub fn FPDFPage_GetDecodedThumbnailData(
        page: FPDF_PAGE,
        buffer: *mut ::std::os::raw::c_void,
        buflen: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Gets the raw data from the thumbnail of |page| if it exists."]
    #[doc = " This only modifies |buffer| if |buflen| is less than or equal to"]
    #[doc = " the size of the raw data. Returns the size of the raw data or 0"]
    #[doc = " if thumbnail DNE. Optional, pass null to just retrieve the size"]
    #[doc = " of the buffer needed."]
    #[doc = ""]
    #[doc = "   page    - handle to a page."]
    #[doc = "   buffer  - buffer for holding the raw image data."]
    #[doc = "   buflen  - length of the buffer in bytes."]
    pub fn FPDFPage_GetRawThumbnailData(
        page: FPDF_PAGE,
        buffer: *mut ::std::os::raw::c_void,
        buflen: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Returns the thumbnail of |page| as a FPDF_BITMAP. Returns a nullptr"]
    #[doc = " if unable to access the thumbnail's stream."]
    #[doc = ""]
    #[doc = "   page - handle to a page."]
    pub fn FPDFPage_GetThumbnailAsBitmap(page: FPDF_PAGE) -> FPDF_BITMAP;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FPDF_IMAGEOBJ_METADATA {
    #[doc = " The image width in pixels."]
    pub width: ::std::os::raw::c_uint,
    #[doc = " The image height in pixels."]
    pub height: ::std::os::raw::c_uint,
    #[doc = " The image's horizontal pixel-per-inch."]
    pub horizontal_dpi: f32,
    #[doc = " The image's vertical pixel-per-inch."]
    pub vertical_dpi: f32,
    #[doc = " The number of bits used to represent each pixel."]
    pub bits_per_pixel: ::std::os::raw::c_uint,
    #[doc = " The image's colorspace. See above for the list of FPDF_COLORSPACE_*."]
    pub colorspace: ::std::os::raw::c_int,
    #[doc = " The image's marked content ID. Useful for pairing with associated alt-text."]
    #[doc = " A value of -1 indicates no ID."]
    pub marked_content_id: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_FPDF_IMAGEOBJ_METADATA() {
    assert_eq!(
        ::std::mem::size_of::<FPDF_IMAGEOBJ_METADATA>(),
        28usize,
        concat!("Size of: ", stringify!(FPDF_IMAGEOBJ_METADATA))
    );
    assert_eq!(
        ::std::mem::align_of::<FPDF_IMAGEOBJ_METADATA>(),
        4usize,
        concat!("Alignment of ", stringify!(FPDF_IMAGEOBJ_METADATA))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_IMAGEOBJ_METADATA>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_IMAGEOBJ_METADATA),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_IMAGEOBJ_METADATA>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_IMAGEOBJ_METADATA),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FPDF_IMAGEOBJ_METADATA>())).horizontal_dpi as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_IMAGEOBJ_METADATA),
            "::",
            stringify!(horizontal_dpi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FPDF_IMAGEOBJ_METADATA>())).vertical_dpi as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_IMAGEOBJ_METADATA),
            "::",
            stringify!(vertical_dpi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FPDF_IMAGEOBJ_METADATA>())).bits_per_pixel as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_IMAGEOBJ_METADATA),
            "::",
            stringify!(bits_per_pixel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FPDF_IMAGEOBJ_METADATA>())).colorspace as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_IMAGEOBJ_METADATA),
            "::",
            stringify!(colorspace)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FPDF_IMAGEOBJ_METADATA>())).marked_content_id as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_IMAGEOBJ_METADATA),
            "::",
            stringify!(marked_content_id)
        )
    );
}
extern "C" {
    #[doc = " Create a new PDF document."]
    #[doc = ""]
    #[doc = " Returns a handle to a new document, or NULL on failure."]
    pub fn FPDF_CreateNewDocument() -> FPDF_DOCUMENT;
}
extern "C" {
    #[doc = " Create a new PDF page."]
    #[doc = ""]
    #[doc = "   document   - handle to document."]
    #[doc = "   page_index - suggested 0-based index of the page to create. If it is larger"]
    #[doc = "                than document's current last index(L), the created page index"]
    #[doc = "                is the next available index -- L+1."]
    #[doc = "   width      - the page width in points."]
    #[doc = "   height     - the page height in points."]
    #[doc = ""]
    #[doc = " Returns the handle to the new page or NULL on failure."]
    #[doc = ""]
    #[doc = " The page should be closed with FPDF_ClosePage() when finished as"]
    #[doc = " with any other page in the document."]
    pub fn FPDFPage_New(
        document: FPDF_DOCUMENT,
        page_index: ::std::os::raw::c_int,
        width: f64,
        height: f64,
    ) -> FPDF_PAGE;
}
extern "C" {
    #[doc = " Delete the page at |page_index|."]
    #[doc = ""]
    #[doc = "   document   - handle to document."]
    #[doc = "   page_index - the index of the page to delete."]
    pub fn FPDFPage_Delete(document: FPDF_DOCUMENT, page_index: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Get the rotation of |page|."]
    #[doc = ""]
    #[doc = "   page - handle to a page"]
    #[doc = ""]
    #[doc = " Returns one of the following indicating the page rotation:"]
    #[doc = "   0 - No rotation."]
    #[doc = "   1 - Rotated 90 degrees clockwise."]
    #[doc = "   2 - Rotated 180 degrees clockwise."]
    #[doc = "   3 - Rotated 270 degrees clockwise."]
    pub fn FPDFPage_GetRotation(page: FPDF_PAGE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set rotation for |page|."]
    #[doc = ""]
    #[doc = "   page   - handle to a page."]
    #[doc = "   rotate - the rotation value, one of:"]
    #[doc = "              0 - No rotation."]
    #[doc = "              1 - Rotated 90 degrees clockwise."]
    #[doc = "              2 - Rotated 180 degrees clockwise."]
    #[doc = "              3 - Rotated 270 degrees clockwise."]
    pub fn FPDFPage_SetRotation(page: FPDF_PAGE, rotate: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Insert |page_obj| into |page|."]
    #[doc = ""]
    #[doc = "   page     - handle to a page"]
    #[doc = "   page_obj - handle to a page object. The |page_obj| will be automatically"]
    #[doc = "              freed."]
    pub fn FPDFPage_InsertObject(page: FPDF_PAGE, page_obj: FPDF_PAGEOBJECT);
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Remove |page_obj| from |page|."]
    #[doc = ""]
    #[doc = "   page     - handle to a page"]
    #[doc = "   page_obj - handle to a page object to be removed."]
    #[doc = ""]
    #[doc = " Returns TRUE on success."]
    #[doc = ""]
    #[doc = " Ownership is transferred to the caller. Call FPDFPageObj_Destroy() to free"]
    #[doc = " it."]
    pub fn FPDFPage_RemoveObject(page: FPDF_PAGE, page_obj: FPDF_PAGEOBJECT) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Get number of page objects inside |page|."]
    #[doc = ""]
    #[doc = "   page - handle to a page."]
    #[doc = ""]
    #[doc = " Returns the number of objects in |page|."]
    pub fn FPDFPage_CountObjects(page: FPDF_PAGE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get object in |page| at |index|."]
    #[doc = ""]
    #[doc = "   page  - handle to a page."]
    #[doc = "   index - the index of a page object."]
    #[doc = ""]
    #[doc = " Returns the handle to the page object, or NULL on failed."]
    pub fn FPDFPage_GetObject(page: FPDF_PAGE, index: ::std::os::raw::c_int) -> FPDF_PAGEOBJECT;
}
extern "C" {
    #[doc = " Checks if |page| contains transparency."]
    #[doc = ""]
    #[doc = "   page - handle to a page."]
    #[doc = ""]
    #[doc = " Returns TRUE if |page| contains transparency."]
    pub fn FPDFPage_HasTransparency(page: FPDF_PAGE) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Generate the content of |page|."]
    #[doc = ""]
    #[doc = "   page - handle to a page."]
    #[doc = ""]
    #[doc = " Returns TRUE on success."]
    #[doc = ""]
    #[doc = " Before you save the page to a file, or reload the page, you must call"]
    #[doc = " |FPDFPage_GenerateContent| or any changes to |page| will be lost."]
    pub fn FPDFPage_GenerateContent(page: FPDF_PAGE) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Destroy |page_obj| by releasing its resources. |page_obj| must have been"]
    #[doc = " created by FPDFPageObj_CreateNew{Path|Rect}() or"]
    #[doc = " FPDFPageObj_New{Text|Image}Obj(). This function must be called on"]
    #[doc = " newly-created objects if they are not added to a page through"]
    #[doc = " FPDFPage_InsertObject() or to an annotation through FPDFAnnot_AppendObject()."]
    #[doc = ""]
    #[doc = "   page_obj - handle to a page object."]
    pub fn FPDFPageObj_Destroy(page_obj: FPDF_PAGEOBJECT);
}
extern "C" {
    #[doc = " Checks if |page_object| contains transparency."]
    #[doc = ""]
    #[doc = "   page_object - handle to a page object."]
    #[doc = ""]
    #[doc = " Returns TRUE if |page_object| contains transparency."]
    pub fn FPDFPageObj_HasTransparency(page_object: FPDF_PAGEOBJECT) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Get type of |page_object|."]
    #[doc = ""]
    #[doc = "   page_object - handle to a page object."]
    #[doc = ""]
    #[doc = " Returns one of the FPDF_PAGEOBJ_* values on success, FPDF_PAGEOBJ_UNKNOWN on"]
    #[doc = " error."]
    pub fn FPDFPageObj_GetType(page_object: FPDF_PAGEOBJECT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Transform |page_object| by the given matrix."]
    #[doc = ""]
    #[doc = "   page_object - handle to a page object."]
    #[doc = "   a           - matrix value."]
    #[doc = "   b           - matrix value."]
    #[doc = "   c           - matrix value."]
    #[doc = "   d           - matrix value."]
    #[doc = "   e           - matrix value."]
    #[doc = "   f           - matrix value."]
    #[doc = ""]
    #[doc = " The matrix is composed as:"]
    #[doc = "   |a c e|"]
    #[doc = "   |b d f|"]
    #[doc = " and can be used to scale, rotate, shear and translate the |page_object|."]
    pub fn FPDFPageObj_Transform(
        page_object: FPDF_PAGEOBJECT,
        a: f64,
        b: f64,
        c: f64,
        d: f64,
        e: f64,
        f: f64,
    );
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Get the transform matrix of a page object."]
    #[doc = ""]
    #[doc = "   page_object - handle to a page object."]
    #[doc = "   matrix      - pointer to struct to receive the matrix value."]
    #[doc = ""]
    #[doc = " The matrix is composed as:"]
    #[doc = "   |a c e|"]
    #[doc = "   |b d f|"]
    #[doc = " and used to scale, rotate, shear and translate the page object."]
    #[doc = ""]
    #[doc = " Returns TRUE on success."]
    pub fn FPDFPageObj_GetMatrix(page_object: FPDF_PAGEOBJECT, matrix: *mut FS_MATRIX)
        -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Set the transform matrix of a page object."]
    #[doc = ""]
    #[doc = "   page_object - handle to a page object."]
    #[doc = "   matrix      - pointer to struct with the matrix value."]
    #[doc = ""]
    #[doc = " The matrix is composed as:"]
    #[doc = "   |a c e|"]
    #[doc = "   |b d f|"]
    #[doc = " and can be used to scale, rotate, shear and translate the page object."]
    #[doc = ""]
    #[doc = " Returns TRUE on success."]
    pub fn FPDFPageObj_SetMatrix(path: FPDF_PAGEOBJECT, matrix: *const FS_MATRIX) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Transform all annotations in |page|."]
    #[doc = ""]
    #[doc = "   page - handle to a page."]
    #[doc = "   a    - matrix value."]
    #[doc = "   b    - matrix value."]
    #[doc = "   c    - matrix value."]
    #[doc = "   d    - matrix value."]
    #[doc = "   e    - matrix value."]
    #[doc = "   f    - matrix value."]
    #[doc = ""]
    #[doc = " The matrix is composed as:"]
    #[doc = "   |a c e|"]
    #[doc = "   |b d f|"]
    #[doc = " and can be used to scale, rotate, shear and translate the |page| annotations."]
    pub fn FPDFPage_TransformAnnots(
        page: FPDF_PAGE,
        a: f64,
        b: f64,
        c: f64,
        d: f64,
        e: f64,
        f: f64,
    );
}
extern "C" {
    #[doc = " Create a new image object."]
    #[doc = ""]
    #[doc = "   document - handle to a document."]
    #[doc = ""]
    #[doc = " Returns a handle to a new image object."]
    pub fn FPDFPageObj_NewImageObj(document: FPDF_DOCUMENT) -> FPDF_PAGEOBJECT;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Get number of content marks in |page_object|."]
    #[doc = ""]
    #[doc = "   page_object - handle to a page object."]
    #[doc = ""]
    #[doc = " Returns the number of content marks in |page_object|, or -1 in case of"]
    #[doc = " failure."]
    pub fn FPDFPageObj_CountMarks(page_object: FPDF_PAGEOBJECT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Get content mark in |page_object| at |index|."]
    #[doc = ""]
    #[doc = "   page_object - handle to a page object."]
    #[doc = "   index       - the index of a page object."]
    #[doc = ""]
    #[doc = " Returns the handle to the content mark, or NULL on failure. The handle is"]
    #[doc = " still owned by the library, and it should not be freed directly. It becomes"]
    #[doc = " invalid if the page object is destroyed, either directly or indirectly by"]
    #[doc = " unloading the page."]
    pub fn FPDFPageObj_GetMark(
        page_object: FPDF_PAGEOBJECT,
        index: ::std::os::raw::c_ulong,
    ) -> FPDF_PAGEOBJECTMARK;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Add a new content mark to a |page_object|."]
    #[doc = ""]
    #[doc = "   page_object - handle to a page object."]
    #[doc = "   name        - the name (tag) of the mark."]
    #[doc = ""]
    #[doc = " Returns the handle to the content mark, or NULL on failure. The handle is"]
    #[doc = " still owned by the library, and it should not be freed directly. It becomes"]
    #[doc = " invalid if the page object is destroyed, either directly or indirectly by"]
    #[doc = " unloading the page."]
    pub fn FPDFPageObj_AddMark(
        page_object: FPDF_PAGEOBJECT,
        name: FPDF_BYTESTRING,
    ) -> FPDF_PAGEOBJECTMARK;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Removes a content |mark| from a |page_object|."]
    #[doc = " The mark handle will be invalid after the removal."]
    #[doc = ""]
    #[doc = "   page_object - handle to a page object."]
    #[doc = "   mark        - handle to a content mark in that object to remove."]
    #[doc = ""]
    #[doc = " Returns TRUE if the operation succeeded, FALSE if it failed."]
    pub fn FPDFPageObj_RemoveMark(
        page_object: FPDF_PAGEOBJECT,
        mark: FPDF_PAGEOBJECTMARK,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Get the name of a content mark."]
    #[doc = ""]
    #[doc = "   mark       - handle to a content mark."]
    #[doc = "   buffer     - buffer for holding the returned name in UTF-16LE. This is only"]
    #[doc = "                modified if |buflen| is longer than the length of the name."]
    #[doc = "                Optional, pass null to just retrieve the size of the buffer"]
    #[doc = "                needed."]
    #[doc = "   buflen     - length of the buffer."]
    #[doc = "   out_buflen - pointer to variable that will receive the minimum buffer size"]
    #[doc = "                to contain the name. Not filled if FALSE is returned."]
    #[doc = ""]
    #[doc = " Returns TRUE if the operation succeeded, FALSE if it failed."]
    pub fn FPDFPageObjMark_GetName(
        mark: FPDF_PAGEOBJECTMARK,
        buffer: *mut ::std::os::raw::c_void,
        buflen: ::std::os::raw::c_ulong,
        out_buflen: *mut ::std::os::raw::c_ulong,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Get the number of key/value pair parameters in |mark|."]
    #[doc = ""]
    #[doc = "   mark   - handle to a content mark."]
    #[doc = ""]
    #[doc = " Returns the number of key/value pair parameters |mark|, or -1 in case of"]
    #[doc = " failure."]
    pub fn FPDFPageObjMark_CountParams(mark: FPDF_PAGEOBJECTMARK) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Get the key of a property in a content mark."]
    #[doc = ""]
    #[doc = "   mark       - handle to a content mark."]
    #[doc = "   index      - index of the property."]
    #[doc = "   buffer     - buffer for holding the returned key in UTF-16LE. This is only"]
    #[doc = "                modified if |buflen| is longer than the length of the key."]
    #[doc = "                Optional, pass null to just retrieve the size of the buffer"]
    #[doc = "                needed."]
    #[doc = "   buflen     - length of the buffer."]
    #[doc = "   out_buflen - pointer to variable that will receive the minimum buffer size"]
    #[doc = "                to contain the key. Not filled if FALSE is returned."]
    #[doc = ""]
    #[doc = " Returns TRUE if the operation was successful, FALSE otherwise."]
    pub fn FPDFPageObjMark_GetParamKey(
        mark: FPDF_PAGEOBJECTMARK,
        index: ::std::os::raw::c_ulong,
        buffer: *mut ::std::os::raw::c_void,
        buflen: ::std::os::raw::c_ulong,
        out_buflen: *mut ::std::os::raw::c_ulong,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Get the type of the value of a property in a content mark by key."]
    #[doc = ""]
    #[doc = "   mark   - handle to a content mark."]
    #[doc = "   key    - string key of the property."]
    #[doc = ""]
    #[doc = " Returns the type of the value, or FPDF_OBJECT_UNKNOWN in case of failure."]
    pub fn FPDFPageObjMark_GetParamValueType(
        mark: FPDF_PAGEOBJECTMARK,
        key: FPDF_BYTESTRING,
    ) -> FPDF_OBJECT_TYPE;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Get the value of a number property in a content mark by key as int."]
    #[doc = " FPDFPageObjMark_GetParamValueType() should have returned FPDF_OBJECT_NUMBER"]
    #[doc = " for this property."]
    #[doc = ""]
    #[doc = "   mark      - handle to a content mark."]
    #[doc = "   key       - string key of the property."]
    #[doc = "   out_value - pointer to variable that will receive the value. Not filled if"]
    #[doc = "               false is returned."]
    #[doc = ""]
    #[doc = " Returns TRUE if the key maps to a number value, FALSE otherwise."]
    pub fn FPDFPageObjMark_GetParamIntValue(
        mark: FPDF_PAGEOBJECTMARK,
        key: FPDF_BYTESTRING,
        out_value: *mut ::std::os::raw::c_int,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Get the value of a string property in a content mark by key."]
    #[doc = ""]
    #[doc = "   mark       - handle to a content mark."]
    #[doc = "   key        - string key of the property."]
    #[doc = "   buffer     - buffer for holding the returned value in UTF-16LE. This is"]
    #[doc = "                only modified if |buflen| is longer than the length of the"]
    #[doc = "                value."]
    #[doc = "                Optional, pass null to just retrieve the size of the buffer"]
    #[doc = "                needed."]
    #[doc = "   buflen     - length of the buffer."]
    #[doc = "   out_buflen - pointer to variable that will receive the minimum buffer size"]
    #[doc = "                to contain the value. Not filled if FALSE is returned."]
    #[doc = ""]
    #[doc = " Returns TRUE if the key maps to a string/blob value, FALSE otherwise."]
    pub fn FPDFPageObjMark_GetParamStringValue(
        mark: FPDF_PAGEOBJECTMARK,
        key: FPDF_BYTESTRING,
        buffer: *mut ::std::os::raw::c_void,
        buflen: ::std::os::raw::c_ulong,
        out_buflen: *mut ::std::os::raw::c_ulong,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Get the value of a blob property in a content mark by key."]
    #[doc = ""]
    #[doc = "   mark       - handle to a content mark."]
    #[doc = "   key        - string key of the property."]
    #[doc = "   buffer     - buffer for holding the returned value. This is only modified"]
    #[doc = "                if |buflen| is at least as long as the length of the value."]
    #[doc = "                Optional, pass null to just retrieve the size of the buffer"]
    #[doc = "                needed."]
    #[doc = "   buflen     - length of the buffer."]
    #[doc = "   out_buflen - pointer to variable that will receive the minimum buffer size"]
    #[doc = "                to contain the value. Not filled if FALSE is returned."]
    #[doc = ""]
    #[doc = " Returns TRUE if the key maps to a string/blob value, FALSE otherwise."]
    pub fn FPDFPageObjMark_GetParamBlobValue(
        mark: FPDF_PAGEOBJECTMARK,
        key: FPDF_BYTESTRING,
        buffer: *mut ::std::os::raw::c_void,
        buflen: ::std::os::raw::c_ulong,
        out_buflen: *mut ::std::os::raw::c_ulong,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Set the value of an int property in a content mark by key. If a parameter"]
    #[doc = " with key |key| exists, its value is set to |value|. Otherwise, it is added as"]
    #[doc = " a new parameter."]
    #[doc = ""]
    #[doc = "   document    - handle to the document."]
    #[doc = "   page_object - handle to the page object with the mark."]
    #[doc = "   mark        - handle to a content mark."]
    #[doc = "   key         - string key of the property."]
    #[doc = "   value       - int value to set."]
    #[doc = ""]
    #[doc = " Returns TRUE if the operation succeeded, FALSE otherwise."]
    pub fn FPDFPageObjMark_SetIntParam(
        document: FPDF_DOCUMENT,
        page_object: FPDF_PAGEOBJECT,
        mark: FPDF_PAGEOBJECTMARK,
        key: FPDF_BYTESTRING,
        value: ::std::os::raw::c_int,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Set the value of a string property in a content mark by key. If a parameter"]
    #[doc = " with key |key| exists, its value is set to |value|. Otherwise, it is added as"]
    #[doc = " a new parameter."]
    #[doc = ""]
    #[doc = "   document    - handle to the document."]
    #[doc = "   page_object - handle to the page object with the mark."]
    #[doc = "   mark        - handle to a content mark."]
    #[doc = "   key         - string key of the property."]
    #[doc = "   value       - string value to set."]
    #[doc = ""]
    #[doc = " Returns TRUE if the operation succeeded, FALSE otherwise."]
    pub fn FPDFPageObjMark_SetStringParam(
        document: FPDF_DOCUMENT,
        page_object: FPDF_PAGEOBJECT,
        mark: FPDF_PAGEOBJECTMARK,
        key: FPDF_BYTESTRING,
        value: FPDF_BYTESTRING,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Set the value of a blob property in a content mark by key. If a parameter"]
    #[doc = " with key |key| exists, its value is set to |value|. Otherwise, it is added as"]
    #[doc = " a new parameter."]
    #[doc = ""]
    #[doc = "   document    - handle to the document."]
    #[doc = "   page_object - handle to the page object with the mark."]
    #[doc = "   mark        - handle to a content mark."]
    #[doc = "   key         - string key of the property."]
    #[doc = "   value       - pointer to blob value to set."]
    #[doc = "   value_len   - size in bytes of |value|."]
    #[doc = ""]
    #[doc = " Returns TRUE if the operation succeeded, FALSE otherwise."]
    pub fn FPDFPageObjMark_SetBlobParam(
        document: FPDF_DOCUMENT,
        page_object: FPDF_PAGEOBJECT,
        mark: FPDF_PAGEOBJECTMARK,
        key: FPDF_BYTESTRING,
        value: *mut ::std::os::raw::c_void,
        value_len: ::std::os::raw::c_ulong,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Removes a property from a content mark by key."]
    #[doc = ""]
    #[doc = "   page_object - handle to the page object with the mark."]
    #[doc = "   mark        - handle to a content mark."]
    #[doc = "   key         - string key of the property."]
    #[doc = ""]
    #[doc = " Returns TRUE if the operation succeeded, FALSE otherwise."]
    pub fn FPDFPageObjMark_RemoveParam(
        page_object: FPDF_PAGEOBJECT,
        mark: FPDF_PAGEOBJECTMARK,
        key: FPDF_BYTESTRING,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Load an image from a JPEG image file and then set it into |image_object|."]
    #[doc = ""]
    #[doc = "   pages        - pointer to the start of all loaded pages, may be NULL."]
    #[doc = "   count        - number of |pages|, may be 0."]
    #[doc = "   image_object - handle to an image object."]
    #[doc = "   file_access  - file access handler which specifies the JPEG image file."]
    #[doc = ""]
    #[doc = " Returns TRUE on success."]
    #[doc = ""]
    #[doc = " The image object might already have an associated image, which is shared and"]
    #[doc = " cached by the loaded pages. In that case, we need to clear the cached image"]
    #[doc = " for all the loaded pages. Pass |pages| and page count (|count|) to this API"]
    #[doc = " to clear the image cache. If the image is not previously shared, or NULL is a"]
    #[doc = " valid |pages| value."]
    pub fn FPDFImageObj_LoadJpegFile(
        pages: *mut FPDF_PAGE,
        count: ::std::os::raw::c_int,
        image_object: FPDF_PAGEOBJECT,
        file_access: *mut FPDF_FILEACCESS,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Load an image from a JPEG image file and then set it into |image_object|."]
    #[doc = ""]
    #[doc = "   pages        - pointer to the start of all loaded pages, may be NULL."]
    #[doc = "   count        - number of |pages|, may be 0."]
    #[doc = "   image_object - handle to an image object."]
    #[doc = "   file_access  - file access handler which specifies the JPEG image file."]
    #[doc = ""]
    #[doc = " Returns TRUE on success."]
    #[doc = ""]
    #[doc = " The image object might already have an associated image, which is shared and"]
    #[doc = " cached by the loaded pages. In that case, we need to clear the cached image"]
    #[doc = " for all the loaded pages. Pass |pages| and page count (|count|) to this API"]
    #[doc = " to clear the image cache. If the image is not previously shared, or NULL is a"]
    #[doc = " valid |pages| value. This function loads the JPEG image inline, so the image"]
    #[doc = " content is copied to the file. This allows |file_access| and its associated"]
    #[doc = " data to be deleted after this function returns."]
    pub fn FPDFImageObj_LoadJpegFileInline(
        pages: *mut FPDF_PAGE,
        count: ::std::os::raw::c_int,
        image_object: FPDF_PAGEOBJECT,
        file_access: *mut FPDF_FILEACCESS,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " TODO(thestig): Start deprecating this once FPDFPageObj_SetMatrix() is stable."]
    #[doc = ""]
    #[doc = " Set the transform matrix of |image_object|."]
    #[doc = ""]
    #[doc = "   image_object - handle to an image object."]
    #[doc = "   a            - matrix value."]
    #[doc = "   b            - matrix value."]
    #[doc = "   c            - matrix value."]
    #[doc = "   d            - matrix value."]
    #[doc = "   e            - matrix value."]
    #[doc = "   f            - matrix value."]
    #[doc = ""]
    #[doc = " The matrix is composed as:"]
    #[doc = "   |a c e|"]
    #[doc = "   |b d f|"]
    #[doc = " and can be used to scale, rotate, shear and translate the |image_object|."]
    #[doc = ""]
    #[doc = " Returns TRUE on success."]
    pub fn FPDFImageObj_SetMatrix(
        image_object: FPDF_PAGEOBJECT,
        a: f64,
        b: f64,
        c: f64,
        d: f64,
        e: f64,
        f: f64,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Set |bitmap| to |image_object|."]
    #[doc = ""]
    #[doc = "   pages        - pointer to the start of all loaded pages, may be NULL."]
    #[doc = "   count        - number of |pages|, may be 0."]
    #[doc = "   image_object - handle to an image object."]
    #[doc = "   bitmap       - handle of the bitmap."]
    #[doc = ""]
    #[doc = " Returns TRUE on success."]
    pub fn FPDFImageObj_SetBitmap(
        pages: *mut FPDF_PAGE,
        count: ::std::os::raw::c_int,
        image_object: FPDF_PAGEOBJECT,
        bitmap: FPDF_BITMAP,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Get a bitmap rasterization of |image_object|. FPDFImageObj_GetBitmap() only"]
    #[doc = " operates on |image_object| and does not take the associated image mask into"]
    #[doc = " account. It also ignores the matrix for |image_object|."]
    #[doc = " The returned bitmap will be owned by the caller, and FPDFBitmap_Destroy()"]
    #[doc = " must be called on the returned bitmap when it is no longer needed."]
    #[doc = ""]
    #[doc = "   image_object - handle to an image object."]
    #[doc = ""]
    #[doc = " Returns the bitmap."]
    pub fn FPDFImageObj_GetBitmap(image_object: FPDF_PAGEOBJECT) -> FPDF_BITMAP;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Get a bitmap rasterization of |image_object| that takes the image mask and"]
    #[doc = " image matrix into account. To render correctly, the caller must provide the"]
    #[doc = " |document| associated with |image_object|. If there is a |page| associated"]
    #[doc = " with |image_object|, the caller should provide that as well."]
    #[doc = " The returned bitmap will be owned by the caller, and FPDFBitmap_Destroy()"]
    #[doc = " must be called on the returned bitmap when it is no longer needed."]
    #[doc = ""]
    #[doc = "   document     - handle to a document associated with |image_object|."]
    #[doc = "   page         - handle to an optional page associated with |image_object|."]
    #[doc = "   image_object - handle to an image object."]
    #[doc = ""]
    #[doc = " Returns the bitmap or NULL on failure."]
    pub fn FPDFImageObj_GetRenderedBitmap(
        document: FPDF_DOCUMENT,
        page: FPDF_PAGE,
        image_object: FPDF_PAGEOBJECT,
    ) -> FPDF_BITMAP;
}
extern "C" {
    #[doc = " Get the decoded image data of |image_object|. The decoded data is the"]
    #[doc = " uncompressed image data, i.e. the raw image data after having all filters"]
    #[doc = " applied. |buffer| is only modified if |buflen| is longer than the length of"]
    #[doc = " the decoded image data."]
    #[doc = ""]
    #[doc = "   image_object - handle to an image object."]
    #[doc = "   buffer       - buffer for holding the decoded image data."]
    #[doc = "   buflen       - length of the buffer in bytes."]
    #[doc = ""]
    #[doc = " Returns the length of the decoded image data."]
    pub fn FPDFImageObj_GetImageDataDecoded(
        image_object: FPDF_PAGEOBJECT,
        buffer: *mut ::std::os::raw::c_void,
        buflen: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Get the raw image data of |image_object|. The raw data is the image data as"]
    #[doc = " stored in the PDF without applying any filters. |buffer| is only modified if"]
    #[doc = " |buflen| is longer than the length of the raw image data."]
    #[doc = ""]
    #[doc = "   image_object - handle to an image object."]
    #[doc = "   buffer       - buffer for holding the raw image data."]
    #[doc = "   buflen       - length of the buffer in bytes."]
    #[doc = ""]
    #[doc = " Returns the length of the raw image data."]
    pub fn FPDFImageObj_GetImageDataRaw(
        image_object: FPDF_PAGEOBJECT,
        buffer: *mut ::std::os::raw::c_void,
        buflen: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Get the number of filters (i.e. decoders) of the image in |image_object|."]
    #[doc = ""]
    #[doc = "   image_object - handle to an image object."]
    #[doc = ""]
    #[doc = " Returns the number of |image_object|'s filters."]
    pub fn FPDFImageObj_GetImageFilterCount(image_object: FPDF_PAGEOBJECT)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the filter at |index| of |image_object|'s list of filters. Note that the"]
    #[doc = " filters need to be applied in order, i.e. the first filter should be applied"]
    #[doc = " first, then the second, etc. |buffer| is only modified if |buflen| is longer"]
    #[doc = " than the length of the filter string."]
    #[doc = ""]
    #[doc = "   image_object - handle to an image object."]
    #[doc = "   index        - the index of the filter requested."]
    #[doc = "   buffer       - buffer for holding filter string, encoded in UTF-8."]
    #[doc = "   buflen       - length of the buffer."]
    #[doc = ""]
    #[doc = " Returns the length of the filter string."]
    pub fn FPDFImageObj_GetImageFilter(
        image_object: FPDF_PAGEOBJECT,
        index: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_void,
        buflen: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Get the image metadata of |image_object|, including dimension, DPI, bits per"]
    #[doc = " pixel, and colorspace. If the |image_object| is not an image object or if it"]
    #[doc = " does not have an image, then the return value will be false. Otherwise,"]
    #[doc = " failure to retrieve any specific parameter would result in its value being 0."]
    #[doc = ""]
    #[doc = "   image_object - handle to an image object."]
    #[doc = "   page         - handle to the page that |image_object| is on. Required for"]
    #[doc = "                  retrieving the image's bits per pixel and colorspace."]
    #[doc = "   metadata     - receives the image metadata; must not be NULL."]
    #[doc = ""]
    #[doc = " Returns true if successful."]
    pub fn FPDFImageObj_GetImageMetadata(
        image_object: FPDF_PAGEOBJECT,
        page: FPDF_PAGE,
        metadata: *mut FPDF_IMAGEOBJ_METADATA,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Create a new path object at an initial position."]
    #[doc = ""]
    #[doc = "   x - initial horizontal position."]
    #[doc = "   y - initial vertical position."]
    #[doc = ""]
    #[doc = " Returns a handle to a new path object."]
    pub fn FPDFPageObj_CreateNewPath(x: f32, y: f32) -> FPDF_PAGEOBJECT;
}
extern "C" {
    #[doc = " Create a closed path consisting of a rectangle."]
    #[doc = ""]
    #[doc = "   x - horizontal position for the left boundary of the rectangle."]
    #[doc = "   y - vertical position for the bottom boundary of the rectangle."]
    #[doc = "   w - width of the rectangle."]
    #[doc = "   h - height of the rectangle."]
    #[doc = ""]
    #[doc = " Returns a handle to the new path object."]
    pub fn FPDFPageObj_CreateNewRect(x: f32, y: f32, w: f32, h: f32) -> FPDF_PAGEOBJECT;
}
extern "C" {
    #[doc = " Get the bounding box of |page_object|."]
    #[doc = ""]
    #[doc = " page_object  - handle to a page object."]
    #[doc = " left         - pointer where the left coordinate will be stored"]
    #[doc = " bottom       - pointer where the bottom coordinate will be stored"]
    #[doc = " right        - pointer where the right coordinate will be stored"]
    #[doc = " top          - pointer where the top coordinate will be stored"]
    #[doc = ""]
    #[doc = " On success, returns TRUE and fills in the 4 coordinates."]
    pub fn FPDFPageObj_GetBounds(
        page_object: FPDF_PAGEOBJECT,
        left: *mut f32,
        bottom: *mut f32,
        right: *mut f32,
        top: *mut f32,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Get the quad points that bounds |page_object|."]
    #[doc = ""]
    #[doc = " page_object  - handle to a page object."]
    #[doc = " quad_points  - pointer where the quadrilateral points will be stored."]
    #[doc = ""]
    #[doc = " On success, returns TRUE and fills in |quad_points|."]
    #[doc = ""]
    #[doc = " Similar to FPDFPageObj_GetBounds(), this returns the bounds of a page"]
    #[doc = " object. When the object is rotated by a non-multiple of 90 degrees, this API"]
    #[doc = " returns a tighter bound that cannot be represented with just the 4 sides of"]
    #[doc = " a rectangle."]
    #[doc = ""]
    #[doc = " Currently only works the following |page_object| types: FPDF_PAGEOBJ_TEXT and"]
    #[doc = " FPDF_PAGEOBJ_IMAGE."]
    pub fn FPDFPageObj_GetRotatedBounds(
        page_object: FPDF_PAGEOBJECT,
        quad_points: *mut FS_QUADPOINTSF,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Set the blend mode of |page_object|."]
    #[doc = ""]
    #[doc = " page_object  - handle to a page object."]
    #[doc = " blend_mode   - string containing the blend mode."]
    #[doc = ""]
    #[doc = " Blend mode can be one of following: Color, ColorBurn, ColorDodge, Darken,"]
    #[doc = " Difference, Exclusion, HardLight, Hue, Lighten, Luminosity, Multiply, Normal,"]
    #[doc = " Overlay, Saturation, Screen, SoftLight"]
    pub fn FPDFPageObj_SetBlendMode(page_object: FPDF_PAGEOBJECT, blend_mode: FPDF_BYTESTRING);
}
extern "C" {
    #[doc = " Set the stroke RGBA of a page object. Range of values: 0 - 255."]
    #[doc = ""]
    #[doc = " page_object  - the handle to the page object."]
    #[doc = " R            - the red component for the object's stroke color."]
    #[doc = " G            - the green component for the object's stroke color."]
    #[doc = " B            - the blue component for the object's stroke color."]
    #[doc = " A            - the stroke alpha for the object."]
    #[doc = ""]
    #[doc = " Returns TRUE on success."]
    pub fn FPDFPageObj_SetStrokeColor(
        page_object: FPDF_PAGEOBJECT,
        R: ::std::os::raw::c_uint,
        G: ::std::os::raw::c_uint,
        B: ::std::os::raw::c_uint,
        A: ::std::os::raw::c_uint,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Get the stroke RGBA of a page object. Range of values: 0 - 255."]
    #[doc = ""]
    #[doc = " page_object  - the handle to the page object."]
    #[doc = " R            - the red component of the path stroke color."]
    #[doc = " G            - the green component of the object's stroke color."]
    #[doc = " B            - the blue component of the object's stroke color."]
    #[doc = " A            - the stroke alpha of the object."]
    #[doc = ""]
    #[doc = " Returns TRUE on success."]
    pub fn FPDFPageObj_GetStrokeColor(
        page_object: FPDF_PAGEOBJECT,
        R: *mut ::std::os::raw::c_uint,
        G: *mut ::std::os::raw::c_uint,
        B: *mut ::std::os::raw::c_uint,
        A: *mut ::std::os::raw::c_uint,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Set the stroke width of a page object."]
    #[doc = ""]
    #[doc = " path   - the handle to the page object."]
    #[doc = " width  - the width of the stroke."]
    #[doc = ""]
    #[doc = " Returns TRUE on success"]
    pub fn FPDFPageObj_SetStrokeWidth(page_object: FPDF_PAGEOBJECT, width: f32) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Get the stroke width of a page object."]
    #[doc = ""]
    #[doc = " path   - the handle to the page object."]
    #[doc = " width  - the width of the stroke."]
    #[doc = ""]
    #[doc = " Returns TRUE on success"]
    pub fn FPDFPageObj_GetStrokeWidth(page_object: FPDF_PAGEOBJECT, width: *mut f32) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Get the line join of |page_object|."]
    #[doc = ""]
    #[doc = " page_object  - handle to a page object."]
    #[doc = ""]
    #[doc = " Returns the line join, or -1 on failure."]
    #[doc = " Line join can be one of following: FPDF_LINEJOIN_MITER, FPDF_LINEJOIN_ROUND,"]
    #[doc = " FPDF_LINEJOIN_BEVEL"]
    pub fn FPDFPageObj_GetLineJoin(page_object: FPDF_PAGEOBJECT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the line join of |page_object|."]
    #[doc = ""]
    #[doc = " page_object  - handle to a page object."]
    #[doc = " line_join    - line join"]
    #[doc = ""]
    #[doc = " Line join can be one of following: FPDF_LINEJOIN_MITER, FPDF_LINEJOIN_ROUND,"]
    #[doc = " FPDF_LINEJOIN_BEVEL"]
    pub fn FPDFPageObj_SetLineJoin(
        page_object: FPDF_PAGEOBJECT,
        line_join: ::std::os::raw::c_int,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Get the line cap of |page_object|."]
    #[doc = ""]
    #[doc = " page_object - handle to a page object."]
    #[doc = ""]
    #[doc = " Returns the line cap, or -1 on failure."]
    #[doc = " Line cap can be one of following: FPDF_LINECAP_BUTT, FPDF_LINECAP_ROUND,"]
    #[doc = " FPDF_LINECAP_PROJECTING_SQUARE"]
    pub fn FPDFPageObj_GetLineCap(page_object: FPDF_PAGEOBJECT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the line cap of |page_object|."]
    #[doc = ""]
    #[doc = " page_object - handle to a page object."]
    #[doc = " line_cap    - line cap"]
    #[doc = ""]
    #[doc = " Line cap can be one of following: FPDF_LINECAP_BUTT, FPDF_LINECAP_ROUND,"]
    #[doc = " FPDF_LINECAP_PROJECTING_SQUARE"]
    pub fn FPDFPageObj_SetLineCap(
        page_object: FPDF_PAGEOBJECT,
        line_cap: ::std::os::raw::c_int,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Set the fill RGBA of a page object. Range of values: 0 - 255."]
    #[doc = ""]
    #[doc = " page_object  - the handle to the page object."]
    #[doc = " R            - the red component for the object's fill color."]
    #[doc = " G            - the green component for the object's fill color."]
    #[doc = " B            - the blue component for the object's fill color."]
    #[doc = " A            - the fill alpha for the object."]
    #[doc = ""]
    #[doc = " Returns TRUE on success."]
    pub fn FPDFPageObj_SetFillColor(
        page_object: FPDF_PAGEOBJECT,
        R: ::std::os::raw::c_uint,
        G: ::std::os::raw::c_uint,
        B: ::std::os::raw::c_uint,
        A: ::std::os::raw::c_uint,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Get the fill RGBA of a page object. Range of values: 0 - 255."]
    #[doc = ""]
    #[doc = " page_object  - the handle to the page object."]
    #[doc = " R            - the red component of the object's fill color."]
    #[doc = " G            - the green component of the object's fill color."]
    #[doc = " B            - the blue component of the object's fill color."]
    #[doc = " A            - the fill alpha of the object."]
    #[doc = ""]
    #[doc = " Returns TRUE on success."]
    pub fn FPDFPageObj_GetFillColor(
        page_object: FPDF_PAGEOBJECT,
        R: *mut ::std::os::raw::c_uint,
        G: *mut ::std::os::raw::c_uint,
        B: *mut ::std::os::raw::c_uint,
        A: *mut ::std::os::raw::c_uint,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Get the line dash |phase| of |page_object|."]
    #[doc = ""]
    #[doc = " page_object - handle to a page object."]
    #[doc = " phase - pointer where the dashing phase will be stored."]
    #[doc = ""]
    #[doc = " Returns TRUE on success."]
    pub fn FPDFPageObj_GetDashPhase(page_object: FPDF_PAGEOBJECT, phase: *mut f32) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Set the line dash phase of |page_object|."]
    #[doc = ""]
    #[doc = " page_object - handle to a page object."]
    #[doc = " phase - line dash phase."]
    #[doc = ""]
    #[doc = " Returns TRUE on success."]
    pub fn FPDFPageObj_SetDashPhase(page_object: FPDF_PAGEOBJECT, phase: f32) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Get the line dash array of |page_object|."]
    #[doc = ""]
    #[doc = " page_object - handle to a page object."]
    #[doc = ""]
    #[doc = " Returns the line dash array size or -1 on failure."]
    pub fn FPDFPageObj_GetDashCount(page_object: FPDF_PAGEOBJECT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Get the line dash array of |page_object|."]
    #[doc = ""]
    #[doc = " page_object - handle to a page object."]
    #[doc = " dash_array - pointer where the dashing array will be stored."]
    #[doc = " dash_count - number of elements in |dash_array|."]
    #[doc = ""]
    #[doc = " Returns TRUE on success."]
    pub fn FPDFPageObj_GetDashArray(
        page_object: FPDF_PAGEOBJECT,
        dash_array: *mut f32,
        dash_count: size_t,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Set the line dash array of |page_object|."]
    #[doc = ""]
    #[doc = " page_object - handle to a page object."]
    #[doc = " dash_array - the dash array."]
    #[doc = " dash_count - number of elements in |dash_array|."]
    #[doc = " phase - the line dash phase."]
    #[doc = ""]
    #[doc = " Returns TRUE on success."]
    pub fn FPDFPageObj_SetDashArray(
        page_object: FPDF_PAGEOBJECT,
        dash_array: *const f32,
        dash_count: size_t,
        phase: f32,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Get number of segments inside |path|."]
    #[doc = ""]
    #[doc = "   path - handle to a path."]
    #[doc = ""]
    #[doc = " A segment is a command, created by e.g. FPDFPath_MoveTo(),"]
    #[doc = " FPDFPath_LineTo() or FPDFPath_BezierTo()."]
    #[doc = ""]
    #[doc = " Returns the number of objects in |path| or -1 on failure."]
    pub fn FPDFPath_CountSegments(path: FPDF_PAGEOBJECT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get segment in |path| at |index|."]
    #[doc = ""]
    #[doc = "   path  - handle to a path."]
    #[doc = "   index - the index of a segment."]
    #[doc = ""]
    #[doc = " Returns the handle to the segment, or NULL on faiure."]
    pub fn FPDFPath_GetPathSegment(
        path: FPDF_PAGEOBJECT,
        index: ::std::os::raw::c_int,
    ) -> FPDF_PATHSEGMENT;
}
extern "C" {
    #[doc = " Get coordinates of |segment|."]
    #[doc = ""]
    #[doc = "   segment  - handle to a segment."]
    #[doc = "   x      - the horizontal position of the segment."]
    #[doc = "   y      - the vertical position of the segment."]
    #[doc = ""]
    #[doc = " Returns TRUE on success, otherwise |x| and |y| is not set."]
    pub fn FPDFPathSegment_GetPoint(
        segment: FPDF_PATHSEGMENT,
        x: *mut f32,
        y: *mut f32,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Get type of |segment|."]
    #[doc = ""]
    #[doc = "   segment - handle to a segment."]
    #[doc = ""]
    #[doc = " Returns one of the FPDF_SEGMENT_* values on success,"]
    #[doc = " FPDF_SEGMENT_UNKNOWN on error."]
    pub fn FPDFPathSegment_GetType(segment: FPDF_PATHSEGMENT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets if the |segment| closes the current subpath of a given path."]
    #[doc = ""]
    #[doc = "   segment - handle to a segment."]
    #[doc = ""]
    #[doc = " Returns close flag for non-NULL segment, FALSE otherwise."]
    pub fn FPDFPathSegment_GetClose(segment: FPDF_PATHSEGMENT) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Move a path's current point."]
    #[doc = ""]
    #[doc = " path   - the handle to the path object."]
    #[doc = " x      - the horizontal position of the new current point."]
    #[doc = " y      - the vertical position of the new current point."]
    #[doc = ""]
    #[doc = " Note that no line will be created between the previous current point and the"]
    #[doc = " new one."]
    #[doc = ""]
    #[doc = " Returns TRUE on success"]
    pub fn FPDFPath_MoveTo(path: FPDF_PAGEOBJECT, x: f32, y: f32) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Add a line between the current point and a new point in the path."]
    #[doc = ""]
    #[doc = " path   - the handle to the path object."]
    #[doc = " x      - the horizontal position of the new point."]
    #[doc = " y      - the vertical position of the new point."]
    #[doc = ""]
    #[doc = " The path's current point is changed to (x, y)."]
    #[doc = ""]
    #[doc = " Returns TRUE on success"]
    pub fn FPDFPath_LineTo(path: FPDF_PAGEOBJECT, x: f32, y: f32) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Add a cubic Bezier curve to the given path, starting at the current point."]
    #[doc = ""]
    #[doc = " path   - the handle to the path object."]
    #[doc = " x1     - the horizontal position of the first Bezier control point."]
    #[doc = " y1     - the vertical position of the first Bezier control point."]
    #[doc = " x2     - the horizontal position of the second Bezier control point."]
    #[doc = " y2     - the vertical position of the second Bezier control point."]
    #[doc = " x3     - the horizontal position of the ending point of the Bezier curve."]
    #[doc = " y3     - the vertical position of the ending point of the Bezier curve."]
    #[doc = ""]
    #[doc = " Returns TRUE on success"]
    pub fn FPDFPath_BezierTo(
        path: FPDF_PAGEOBJECT,
        x1: f32,
        y1: f32,
        x2: f32,
        y2: f32,
        x3: f32,
        y3: f32,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Close the current subpath of a given path."]
    #[doc = ""]
    #[doc = " path   - the handle to the path object."]
    #[doc = ""]
    #[doc = " This will add a line between the current point and the initial point of the"]
    #[doc = " subpath, thus terminating the current subpath."]
    #[doc = ""]
    #[doc = " Returns TRUE on success"]
    pub fn FPDFPath_Close(path: FPDF_PAGEOBJECT) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Set the drawing mode of a path."]
    #[doc = ""]
    #[doc = " path     - the handle to the path object."]
    #[doc = " fillmode - the filling mode to be set: one of the FPDF_FILLMODE_* flags."]
    #[doc = " stroke   - a boolean specifying if the path should be stroked or not."]
    #[doc = ""]
    #[doc = " Returns TRUE on success"]
    pub fn FPDFPath_SetDrawMode(
        path: FPDF_PAGEOBJECT,
        fillmode: ::std::os::raw::c_int,
        stroke: FPDF_BOOL,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Get the drawing mode of a path."]
    #[doc = ""]
    #[doc = " path     - the handle to the path object."]
    #[doc = " fillmode - the filling mode of the path: one of the FPDF_FILLMODE_* flags."]
    #[doc = " stroke   - a boolean specifying if the path is stroked or not."]
    #[doc = ""]
    #[doc = " Returns TRUE on success"]
    pub fn FPDFPath_GetDrawMode(
        path: FPDF_PAGEOBJECT,
        fillmode: *mut ::std::os::raw::c_int,
        stroke: *mut FPDF_BOOL,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Create a new text object using one of the standard PDF fonts."]
    #[doc = ""]
    #[doc = " document   - handle to the document."]
    #[doc = " font       - string containing the font name, without spaces."]
    #[doc = " font_size  - the font size for the new text object."]
    #[doc = ""]
    #[doc = " Returns a handle to a new text object, or NULL on failure"]
    pub fn FPDFPageObj_NewTextObj(
        document: FPDF_DOCUMENT,
        font: FPDF_BYTESTRING,
        font_size: f32,
    ) -> FPDF_PAGEOBJECT;
}
extern "C" {
    #[doc = " Set the text for a text object. If it had text, it will be replaced."]
    #[doc = ""]
    #[doc = " text_object  - handle to the text object."]
    #[doc = " text         - the UTF-16LE encoded string containing the text to be added."]
    #[doc = ""]
    #[doc = " Returns TRUE on success"]
    pub fn FPDFText_SetText(text_object: FPDF_PAGEOBJECT, text: FPDF_WIDESTRING) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Set the text using charcodes for a text object. If it had text, it will be"]
    #[doc = " replaced."]
    #[doc = ""]
    #[doc = " text_object  - handle to the text object."]
    #[doc = " charcodes    - pointer to an array of charcodes to be added."]
    #[doc = " count        - number of elements in |charcodes|."]
    #[doc = ""]
    #[doc = " Returns TRUE on success"]
    pub fn FPDFText_SetCharcodes(
        text_object: FPDF_PAGEOBJECT,
        charcodes: *const u32,
        count: size_t,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Returns a font object loaded from a stream of data. The font is loaded"]
    #[doc = " into the document."]
    #[doc = ""]
    #[doc = " document   - handle to the document."]
    #[doc = " data       - the stream of data, which will be copied by the font object."]
    #[doc = " size       - size of the stream, in bytes."]
    #[doc = " font_type  - FPDF_FONT_TYPE1 or FPDF_FONT_TRUETYPE depending on the font"]
    #[doc = " type."]
    #[doc = " cid        - a boolean specifying if the font is a CID font or not."]
    #[doc = ""]
    #[doc = " The loaded font can be closed using FPDFFont_Close."]
    #[doc = ""]
    #[doc = " Returns NULL on failure"]
    pub fn FPDFText_LoadFont(
        document: FPDF_DOCUMENT,
        data: *const u8,
        size: u32,
        font_type: ::std::os::raw::c_int,
        cid: FPDF_BOOL,
    ) -> FPDF_FONT;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Loads one of the standard 14 fonts per PDF spec 1.7 page 416. The preferred"]
    #[doc = " way of using font style is using a dash to separate the name from the style,"]
    #[doc = " for example 'Helvetica-BoldItalic'."]
    #[doc = ""]
    #[doc = " document   - handle to the document."]
    #[doc = " font       - string containing the font name, without spaces."]
    #[doc = ""]
    #[doc = " The loaded font can be closed using FPDFFont_Close."]
    #[doc = ""]
    #[doc = " Returns NULL on failure."]
    pub fn FPDFText_LoadStandardFont(document: FPDF_DOCUMENT, font: FPDF_BYTESTRING) -> FPDF_FONT;
}
extern "C" {
    #[doc = " Get the font size of a text object."]
    #[doc = ""]
    #[doc = "   text - handle to a text."]
    #[doc = "   size - pointer to the font size of the text object, measured in points"]
    #[doc = "   (about 1/72 inch)"]
    #[doc = ""]
    #[doc = " Returns TRUE on success."]
    pub fn FPDFTextObj_GetFontSize(text: FPDF_PAGEOBJECT, size: *mut f32) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Close a loaded PDF font."]
    #[doc = ""]
    #[doc = " font   - Handle to the loaded font."]
    pub fn FPDFFont_Close(font: FPDF_FONT);
}
extern "C" {
    #[doc = " Create a new text object using a loaded font."]
    #[doc = ""]
    #[doc = " document   - handle to the document."]
    #[doc = " font       - handle to the font object."]
    #[doc = " font_size  - the font size for the new text object."]
    #[doc = ""]
    #[doc = " Returns a handle to a new text object, or NULL on failure"]
    pub fn FPDFPageObj_CreateTextObj(
        document: FPDF_DOCUMENT,
        font: FPDF_FONT,
        font_size: f32,
    ) -> FPDF_PAGEOBJECT;
}
extern "C" {
    #[doc = " Get the text rendering mode of a text object."]
    #[doc = ""]
    #[doc = " text     - the handle to the text object."]
    #[doc = ""]
    #[doc = " Returns one of the known FPDF_TEXT_RENDERMODE enum values on success,"]
    #[doc = " FPDF_TEXTRENDERMODE_UNKNOWN on error."]
    pub fn FPDFTextObj_GetTextRenderMode(text: FPDF_PAGEOBJECT) -> FPDF_TEXT_RENDERMODE;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Set the text rendering mode of a text object."]
    #[doc = ""]
    #[doc = " text         - the handle to the text object."]
    #[doc = " render_mode  - the FPDF_TEXT_RENDERMODE enum value to be set (cannot set to"]
    #[doc = "                FPDF_TEXTRENDERMODE_UNKNOWN)."]
    #[doc = ""]
    #[doc = " Returns TRUE on success."]
    pub fn FPDFTextObj_SetTextRenderMode(
        text: FPDF_PAGEOBJECT,
        render_mode: FPDF_TEXT_RENDERMODE,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Get the text of a text object."]
    #[doc = ""]
    #[doc = " text_object      - the handle to the text object."]
    #[doc = " text_page        - the handle to the text page."]
    #[doc = " buffer           - the address of a buffer that receives the text."]
    #[doc = " length           - the size, in bytes, of |buffer|."]
    #[doc = ""]
    #[doc = " Returns the number of bytes in the text (including the trailing NUL"]
    #[doc = " character) on success, 0 on error."]
    #[doc = ""]
    #[doc = " Regardless of the platform, the |buffer| is always in UTF-16LE encoding."]
    #[doc = " If |length| is less than the returned length, or |buffer| is NULL, |buffer|"]
    #[doc = " will not be modified."]
    pub fn FPDFTextObj_GetText(
        text_object: FPDF_PAGEOBJECT,
        text_page: FPDF_TEXTPAGE,
        buffer: *mut FPDF_WCHAR,
        length: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Get a bitmap rasterization of |text_object|. To render correctly, the caller"]
    #[doc = " must provide the |document| associated with |text_object|. If there is a"]
    #[doc = " |page| associated with |text_object|, the caller should provide that as well."]
    #[doc = " The returned bitmap will be owned by the caller, and FPDFBitmap_Destroy()"]
    #[doc = " must be called on the returned bitmap when it is no longer needed."]
    #[doc = ""]
    #[doc = "   document    - handle to a document associated with |text_object|."]
    #[doc = "   page        - handle to an optional page associated with |text_object|."]
    #[doc = "   text_object - handle to a text object."]
    #[doc = "   scale       - the scaling factor, which must be greater than 0."]
    #[doc = ""]
    #[doc = " Returns the bitmap or NULL on failure."]
    pub fn FPDFTextObj_GetRenderedBitmap(
        document: FPDF_DOCUMENT,
        page: FPDF_PAGE,
        text_object: FPDF_PAGEOBJECT,
        scale: f32,
    ) -> FPDF_BITMAP;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Get the font of a text object."]
    #[doc = ""]
    #[doc = " text - the handle to the text object."]
    #[doc = ""]
    #[doc = " Returns a handle to the font object held by |text| which retains ownership."]
    pub fn FPDFTextObj_GetFont(text: FPDF_PAGEOBJECT) -> FPDF_FONT;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Get the font name of a font."]
    #[doc = ""]
    #[doc = " font   - the handle to the font object."]
    #[doc = " buffer - the address of a buffer that receives the font name."]
    #[doc = " length - the size, in bytes, of |buffer|."]
    #[doc = ""]
    #[doc = " Returns the number of bytes in the font name (including the trailing NUL"]
    #[doc = " character) on success, 0 on error."]
    #[doc = ""]
    #[doc = " Regardless of the platform, the |buffer| is always in UTF-8 encoding."]
    #[doc = " If |length| is less than the returned length, or |buffer| is NULL, |buffer|"]
    #[doc = " will not be modified."]
    pub fn FPDFFont_GetFontName(
        font: FPDF_FONT,
        buffer: *mut ::std::os::raw::c_char,
        length: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Get the decoded data from the |font| object."]
    #[doc = ""]
    #[doc = " font       - The handle to the font object. (Required)"]
    #[doc = " buffer     - The address of a buffer that receives the font data."]
    #[doc = " buflen     - Length of the buffer."]
    #[doc = " out_buflen - Pointer to variable that will receive the minimum buffer size"]
    #[doc = "              to contain the font data. Not filled if the return value is"]
    #[doc = "              FALSE. (Required)"]
    #[doc = ""]
    #[doc = " Returns TRUE on success. In which case, |out_buflen| will be filled, and"]
    #[doc = " |buffer| will be filled if it is large enough. Returns FALSE if any of the"]
    #[doc = " required parameters are null."]
    #[doc = ""]
    #[doc = " The decoded data is the uncompressed font data. i.e. the raw font data after"]
    #[doc = " having all stream filters applied, when the data is embedded."]
    #[doc = ""]
    #[doc = " If the font is not embedded, then this API will instead return the data for"]
    #[doc = " the substitution font it is using."]
    pub fn FPDFFont_GetFontData(
        font: FPDF_FONT,
        buffer: *mut u8,
        buflen: size_t,
        out_buflen: *mut size_t,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Get whether |font| is embedded or not."]
    #[doc = ""]
    #[doc = " font - the handle to the font object."]
    #[doc = ""]
    #[doc = " Returns 1 if the font is embedded, 0 if it not, and -1 on failure."]
    pub fn FPDFFont_GetIsEmbedded(font: FPDF_FONT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Get the descriptor flags of a font."]
    #[doc = ""]
    #[doc = " font - the handle to the font object."]
    #[doc = ""]
    #[doc = " Returns the bit flags specifying various characteristics of the font as"]
    #[doc = " defined in ISO 32000-1:2008, table 123, -1 on failure."]
    pub fn FPDFFont_GetFlags(font: FPDF_FONT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Get the font weight of a font."]
    #[doc = ""]
    #[doc = " font - the handle to the font object."]
    #[doc = ""]
    #[doc = " Returns the font weight, -1 on failure."]
    #[doc = " Typical values are 400 (normal) and 700 (bold)."]
    pub fn FPDFFont_GetWeight(font: FPDF_FONT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Get the italic angle of a font."]
    #[doc = ""]
    #[doc = " font  - the handle to the font object."]
    #[doc = " angle - pointer where the italic angle will be stored"]
    #[doc = ""]
    #[doc = " The italic angle of a |font| is defined as degrees counterclockwise"]
    #[doc = " from vertical. For a font that slopes to the right, this will be negative."]
    #[doc = ""]
    #[doc = " Returns TRUE on success; |angle| unmodified on failure."]
    pub fn FPDFFont_GetItalicAngle(font: FPDF_FONT, angle: *mut ::std::os::raw::c_int)
        -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Get ascent distance of a font."]
    #[doc = ""]
    #[doc = " font       - the handle to the font object."]
    #[doc = " font_size  - the size of the |font|."]
    #[doc = " ascent     - pointer where the font ascent will be stored"]
    #[doc = ""]
    #[doc = " Ascent is the maximum distance in points above the baseline reached by the"]
    #[doc = " glyphs of the |font|. One point is 1/72 inch (around 0.3528 mm)."]
    #[doc = ""]
    #[doc = " Returns TRUE on success; |ascent| unmodified on failure."]
    pub fn FPDFFont_GetAscent(font: FPDF_FONT, font_size: f32, ascent: *mut f32) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Get descent distance of a font."]
    #[doc = ""]
    #[doc = " font       - the handle to the font object."]
    #[doc = " font_size  - the size of the |font|."]
    #[doc = " descent    - pointer where the font descent will be stored"]
    #[doc = ""]
    #[doc = " Descent is the maximum distance in points below the baseline reached by the"]
    #[doc = " glyphs of the |font|. One point is 1/72 inch (around 0.3528 mm)."]
    #[doc = ""]
    #[doc = " Returns TRUE on success; |descent| unmodified on failure."]
    pub fn FPDFFont_GetDescent(font: FPDF_FONT, font_size: f32, descent: *mut f32) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Get the width of a glyph in a font."]
    #[doc = ""]
    #[doc = " font       - the handle to the font object."]
    #[doc = " glyph      - the glyph."]
    #[doc = " font_size  - the size of the font."]
    #[doc = " width      - pointer where the glyph width will be stored"]
    #[doc = ""]
    #[doc = " Glyph width is the distance from the end of the prior glyph to the next"]
    #[doc = " glyph. This will be the vertical distance for vertical writing."]
    #[doc = ""]
    #[doc = " Returns TRUE on success; |width| unmodified on failure."]
    pub fn FPDFFont_GetGlyphWidth(
        font: FPDF_FONT,
        glyph: u32,
        font_size: f32,
        width: *mut f32,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Get the glyphpath describing how to draw a font glyph."]
    #[doc = ""]
    #[doc = " font       - the handle to the font object."]
    #[doc = " glyph      - the glyph being drawn."]
    #[doc = " font_size  - the size of the font."]
    #[doc = ""]
    #[doc = " Returns the handle to the segment, or NULL on faiure."]
    pub fn FPDFFont_GetGlyphPath(font: FPDF_FONT, glyph: u32, font_size: f32) -> FPDF_GLYPHPATH;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Get number of segments inside glyphpath."]
    #[doc = ""]
    #[doc = " glyphpath - handle to a glyph path."]
    #[doc = ""]
    #[doc = " Returns the number of objects in |glyphpath| or -1 on failure."]
    pub fn FPDFGlyphPath_CountGlyphSegments(glyphpath: FPDF_GLYPHPATH) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Get segment in glyphpath at index."]
    #[doc = ""]
    #[doc = " glyphpath  - handle to a glyph path."]
    #[doc = " index      - the index of a segment."]
    #[doc = ""]
    #[doc = " Returns the handle to the segment, or NULL on faiure."]
    pub fn FPDFGlyphPath_GetGlyphPathSegment(
        glyphpath: FPDF_GLYPHPATH,
        index: ::std::os::raw::c_int,
    ) -> FPDF_PATHSEGMENT;
}
extern "C" {
    #[doc = " Get number of page objects inside |form_object|."]
    #[doc = ""]
    #[doc = "   form_object - handle to a form object."]
    #[doc = ""]
    #[doc = " Returns the number of objects in |form_object| on success, -1 on error."]
    pub fn FPDFFormObj_CountObjects(form_object: FPDF_PAGEOBJECT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get page object in |form_object| at |index|."]
    #[doc = ""]
    #[doc = "   form_object - handle to a form object."]
    #[doc = "   index       - the 0-based index of a page object."]
    #[doc = ""]
    #[doc = " Returns the handle to the page object, or NULL on error."]
    pub fn FPDFFormObj_GetObject(
        form_object: FPDF_PAGEOBJECT,
        index: ::std::os::raw::c_ulong,
    ) -> FPDF_PAGEOBJECT;
}
